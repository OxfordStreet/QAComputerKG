{ "动态存储方式":{"key":["动态存储方式"],"property":["同义关系"],"to_name":["静态存储方式"],"重要程度":[3],"所属章节":[7],"知识点描述":["动态存储方式则是在程序运行期间根据需要进行动态的分配。"]}, "静态存储方式":{"key":["静态存储方式"],"property":["同义关系"],"to_name":["函数调用时的数据传递"],"重要程度":[3],"所属章节":[7],"知识点描述":["静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式。"]}, "全局变量":{"key":["全局变量"],"property":["同义关系"],"to_name":["局部变量"],"重要程度":[3],"所属章节":[7],"知识点描述":["在函数内定义的变量是局部变量,而在函数之外定义的变量称为外部变量，外部变量是全局变量(也称全程变量)。全局变量可以为本文件中其他函数所共用。"]}, "局部变量":{ "key":[ "局部变量" ], "property":[ "同义关系" ], "to_name":[ "函数调用时的数据传递" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "在复合语句内定义的变量只在本复合语句范围内有效,只有在本复合语句内才能引用它们。在该复合语句以外是不能使用这些变量的，以上这些称为“局部变量”。" ] }, "外部函数":{ "key":[ "外部函数" ], "property":[ "同义关系" ], "to_name":[ "内部函数" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "如果在定义函数时，在函数首部的最左端加关键字extern,则此函数是外部函数,可供其他文件调用。如函数首部可以为extern int fun (int a, int b)" ] }, "内部函数":{ "key":[ "内部函数" ], "property":[ "同义关系" ], "to_name":[ "函数调用时的数据传递" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "如果一个函数只能被本文件中其他函数所调用,它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加static,即:static类型名函数名(形参表);" ] }, "数组名作函数参数":{ "key":[ "数组名作函数参数" ], "property":[ "subclassof" ], "to_name":[ "函数调用时的数据传递" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ "用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数实参时，向形参(数组名或指针变量)传递的是数组首元素的地址。" ] }, "数组元素作函数实参":{ "key":[ "数组元素作函数实参" ], "property":[ "subclassof" ], "to_name":[ "函数调用时的数据传递" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ "在用数组元素作函数实参时,把实参的值传给形参。数据传递的方向是从实参传到形参，单向传递。" ] }, "函数调用时的数据传递":{ "key":[ "函数调用时的数据传递" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ "形式参数和实际参数；实参和形参间的数据传递" ] }, "数组元素的指针":{ "key":[ "数组元素的指针" ], "property":[ "subclassof" ], "to_name":[ "指针变量" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "一一个变量有地址，一个数组包含若千元素，每个数组元素都在内存中占用存储单元，它们都有相应的地址。指针变量既然可以指向变量，当然也可以指向数组元素(把某一元素的地址放到一个指针变量中)。所谓数组元素的指针就是数组元素的地址。" ] }, "返回指针值的函数":{ "key":[ "返回指针值的函数" ], "property":[ "subclassof" ], "to_name":[ "指针变量" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "定义返回指针值的函数的一般形式为:类型名*函数名(参数表列);" ] }, "定义指针变量":{ "key":[ "定义指针变量" ], "property":[ "subclassof" ], "to_name":[ "指针变量" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "定义指针变量的一般形式为：类型名* 指针变量名;" ] }, "内存的动态分配":{ "key":[ "内存的动态分配" ], "property":[ "subclassof" ], "to_name":[ "指针数组" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "C语言允许建立内存动态分配区域，以存放一些临时用的数据,这些数据不必在程序的声明部分定义,也不必等到函数结束时才释放，而是需要时随时开辟,不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为堆(heap)区。" ] }, "malloc函数":{ "key":[ "malloc函数" ], "property":[ "subclassof" ], "to_name":[ "指针数组" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "其函数原型为void￥malloc( unsigned int size) ;" ] }, "calloc函数":{ "key":[ "calloc函数" ], "property":[ "subclassof" ], "to_name":[ "指针数组" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "其函数原型为void * calloc( unsigned n, unsigned size) ;" ] }, "free函数":{ "key":[ "free函数" ], "property":[ "subclassof" ], "to_name":[ "指针数组" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "其函数原型为void free(void * p) ;" ] }, "realloc函数":{ "key":[ "realloc函数" ], "property":[ "subclassof" ], "to_name":[ "指针数组" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "其函数原型为void * realloc( void *p, unsigned int size) ;" ] }, "指针数组":{ "key":[ "指针数组" ], "property":[ "type" ], "to_name":[ "指针" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "一个数组,若其元素均为指针类型数据,称为指针数组，也就是说,指针数组中的每一个元素都存放-一个地址，相当于一个指针变量。" ] }, "指针变量":{ "key":[ "指针变量" ], "property":[ "type" ], "to_name":[ "指针" ], "重要程度":[ 2 ], "所属章节":[ 8 ], "知识点描述":[ "指针变量是存放一个变量地址的变量，不同于其他类型变量，它是专门用来存放内存地址的，也称为地址变量。定义指针变量的一般形式为：类型说明符*变量名。" ] }, "指针":{ "key":[ "指针" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 8 ], "知识点描述":[ "指针，是C语言中的一个重要概念及其特点，也是掌握C语言比较困难的部分。指针也就是内存地址，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。" ] }, "ferror函数":{ "key":[ "ferror函数" ], "property":[ "同义关系" ], "to_name":[ "打开与关闭文件" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "在调用各种输人输出函数(如putc, getc, fread,fwrite等)时，如果出现错误,除了函数返回值有所反映外,还可以用ferror函数检查。它的一般调用形式为ferror(fp) ;" ] }, "clearerr 函数":{ "key":[ "clearerr 函数" ], "property":[ "同义关系" ], "to_name":[ "打开与关闭文件" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "clearerr的作用是使文件错误标志和文件结束标志置为0。假设在调用-一个输人输出函数时出现错误,ferror函数值为一个非零值。应该立即调用clearerr(fp)，使ferror(fp) 的值变成0,以便再进行下一次的检测。" ] }, "文件读写的出错检测":{ "key":[ "文件读写的出错检测" ], "property":[ "同义关系" ], "to_name":[ "打开与关闭文件" ], "重要程度":[ 5 ], "所属章节":[ 10 ], "知识点描述":[ "C提供一些函数用来检查输人输出函数调用时可能出现的错误。1. ferror函数；2. clearerr 函数" ] }, "文件位置标记的定位":{ "key":[ "文件位置标记的定位" ], "property":[ "同义关系" ], "to_name":[ "打开与关闭文件" ], "重要程度":[ 5 ], "所属章节":[ 10 ], "知识点描述":[ "用rewind函数使文件位置标记指向文件开头；用fseek函数改变文件位置标记；用ftell函数测定文件位置标记的当前位置；" ] }, "打开与关闭文件":{ "key":[ "打开与关闭文件" ], "property":[ "type" ], "to_name":[ "程序文件" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "用fopen函数打开数据文件：fopen(文件名,使用文件方式); 用fclose函数关闭数据文件fclose(文件指针) ;" ] }, "数据文件":{ "key":[ "数据文件" ], "property":[ "同义关系" ], "to_name":[ "程序文件" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "文件的内容不是程序，而是供程序运行时读写的数据,如在程序运行过程中输出到磁盘(或其他外部设备)的数据,或在程序运行过程中供读人的数据。如一批学生的成绩数据、货物交易的数据等。" ] }, "文件名":{ "key":[ "文件名" ], "property":[ "同义关系" ], "to_name":[ "程序文件" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "一个文件要有一个唯一的文件标识，以便用户识别和引用。文件标识包括3部分: (1)文件路径; (2)文件名主干; (3)文件后缀。" ] }, "程序文件":{ "key":[ "程序文件" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "包括源程序文件(后缀为. c)、目标文件(后缀为. obj)、可执行文件(后缀为.exe)等。这种文件的内容是程序代码" ] }, "break语句":{ "key":[ "break语句" ], "property":[ "前驱关系" ], "to_name":[ "循环结构程序设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "break语句是中断当前循环，通常在 switch 语句和 while、for、for...in、或 do...while 循环中使用 break 语句。执行 break 语句会退出当前循环或语句，并开始脚本执行紧接着的语句。" ] }, "continue语句":{ "key":[ "continue语句" ], "property":[ "前驱关系" ], "to_name":[ "循环结构程序设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "表示结束本次循环，而不终止整个循环的执行。而是结束本次循环，进行下一次循环。continue语句只结束本次循环，而不终止整个循环的执行。而break语句则是结束整个循环过程，不再判断执行循环的条件是否成立。" ] }, "循环结构程序设计":{ "key":[ "循环结构程序设计" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 5 ], "所属章节":[ 5 ], "知识点描述":[ "用while语句实现循环；用do...while语句实现循环；用for语句实现循环" ] }, "输出字符串的函数":{ "key":[ "输出字符串的函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "puts函数；其一般形式为：puts (字符数组)" ] }, "转换为小写的函数":{ "key":[ "转换为小写的函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "strlwr函数；其一般形式为：strIwr (字符串)" ] }, "转换为大写的函数":{ "key":[ "转换为大写的函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "strupr函数；其一般形式为：strupr (字符串)" ] }, "测字符串长度的函数":{ "key":[ "测字符串长度的函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "strlen函数；其一般形式为：strlen (字符数组)" ] }, "字符串比较函数":{ "key":[ "字符串比较函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "strcmp函数；其一般形式为：strcmp(字符串1,字符串2)" ] }, "字符串复制函数":{ "key":[ "字符串复制函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "strepy和strncpy函数；其一般形式为：strcpy(字符数组1,字符串2)" ] }, "字符串连接函数":{ "key":[ "字符串连接函数" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "strcat函数；其一般形式为：strcat(字符数组1,字符数组2)" ] }, "字符数组的输入输出":{ "key":[ "字符数组的输入输出" ], "property":[ "subclassof" ], "to_name":[ "字符数组" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "(1)逐个字符输人输出。用格式符“%c”输人或输出一一个字符；(2)将整个字符串--次输人或输出。用“%s”格式符，意思是对字符串(string)的输人输出。" ] }, "字符数组":{ "key":[ "字符数组" ], "property":[ "subclassof" ], "to_name":[ "数组" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "字符数组是指用来存放字符数据的数组。其定义的一般形式为： char 数组名[数据长度] 。字符数组用于存放字符或字符串，字符数组中的一个元素存放一个字符，它在内存中占用一个字节。C语言中没有字符串类型，字符串是存放在字符型数组中的。" ] }, "二维数组":{ "key":[ "二维数组" ], "property":[ "subclassof" ], "to_name":[ "数组" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "二维数组常称为矩阵(matrix)。把二维数组写成行(column)和列(row)的排列形式，可以有助于形象化地理解二维数组的逻辑结构。" ] }, "数组":{ "key":[ "数组" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "所谓数组，是有序的元素序列。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。这些有序排列的同类数据元素的集合称为数组。数组是用于储存多个相同类型数据的集合。" ] }, "标识符":{ "key":[ "标识符" ], "property":[ "同义关系" ], "to_name":[ "常量" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "在计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。标识符通常由字母和数字以及其它字符构成。" ] }, "整型数据":{ "key":[ "整型数据" ], "property":[ "同义关系" ], "to_name":[ "常量" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "整型（INTEGER）数据是不包含小数部分的数值型数据，用字母I表示。整型数据只用来表示整数，以二进制形式存储。" ] }, "字符型数据":{ "key":[ "字符型数据" ], "property":[ "同义关系" ], "to_name":[ "常量" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "字符型（Character）数据是不具计算能力的文字数据类型，它包括中文字符、英文字符、数字字符和其他ASCⅡ字符，其长度（即字符个数）范围是0-255个字符，即0x00至0xFF。" ] }, "变量":{ "key":[ "变量" ], "property":[ "同义关系" ], "to_name":[ "常量" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "在程序运行期间,变量的值是可以改变的。" ] }, "浮点型数据":{ "key":[ "浮点型数据" ], "property":[ "同义关系" ], "to_name":[ "常量" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "浮点型数据分为 浮点型常量和浮点型变量" ] }, "常量":{ "key":[ "常量" ], "property":[ "subclassof" ], "to_name":[ "C语句分类" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "在程序运行过程中,其值不能被改变的量称为常量。" ] }, "字符数据的输入输出":{ "key":[ "字符数据的输入输出" ], "property":[ "subclassof" ], "to_name":[ "C语句分类" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "用putchar函数输出一个字符；用getchar函数输入一个字符" ] }, "C语句分类":{ "key":[ "C语句分类" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 5 ], "所属章节":[ 3 ], "知识点描述":[ "控制语句；函数调用语句；表达式语句；空语句；复合语句" ] }, "汇编语言":{ "key":[ "汇编语言" ], "property":[ "subclassof" ], "to_name":[ "计算机语言" ], "重要程度":[ 5 ], "所属章节":[ 1 ], "知识点描述":[ "汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。" ] }, "机器语言":{ "key":[ "机器语言" ], "property":[ "subclassof" ], "to_name":[ "计算机语言" ], "重要程度":[ 5 ], "所属章节":[ 1 ], "知识点描述":[ "计算机能直接识别和接受的二进制代码称为机器指令(machineinstruction)。机器指令的集合就是该计算机的机器语言(machinelanguage)。" ] }, "高级语言":{ "key":[ "高级语言" ], "property":[ "subclassof" ], "to_name":[ "计算机语言" ], "重要程度":[ 5 ], "所属章节":[ 1 ], "知识点描述":[ "高级语言（High-level programming language）是一种独立于机器，面向过程或对象的语言。" ] }, "C语言特点":{ "key":[ "C语言特点" ], "property":[ "同义关系" ], "to_name":[ "计算机程序" ], "重要程度":[ 5 ], "所属章节":[ 1 ], "知识点描述":[ "（1）简洁的语言（2）具有结构化的控制语句（3）丰富的数据类型（4）丰富的运算符（5）可对物理地址进行直接操作（6）代码具有较好的可移植性（7）可生成高质量、目标代码执行效率高的程序" ] }, "计算机语言":{ "key":[ "计算机语言" ], "property":[ "同义关系" ], "to_name":[ "计算机程序" ], "重要程度":[ 5 ], "所属章节":[ 1 ], "知识点描述":[ "计算机语言（Computer Language）指用于人与计算机之间通讯的语言。计算机语言是人与计算机之间传递信息的媒介。" ] }, "计算机程序":{ "key":[ "计算机程序" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 5 ], "所属章节":[ 1 ], "知识点描述":[ "所谓程序,就是一组计算机能识别和执行的指令。每一条指令使计算机执行特定的操作。只要让计算机执行这个程序，计算机就会自动地执行各条指令,有条不紊地进行工作。" ] }, "结构体指针":{ "key":[ "结构体指针" ], "property":[ "subclassof" ], "to_name":[ "结构体" ], "重要程度":[ 4 ], "所属章节":[ 9 ], "知识点描述":[ "所谓结构体指针就是指向结构体变量的指针,一个结构体变量的起始地址就是这个结构体变量的指针。如果把-一个结构体变量的起始地址存放在-个 指针变量中,那么,这个指针变量就指向该结构体变量。" ] }, "结构体变量的初始化和引用":{ "key":[ "结构体变量的初始化和引用" ], "property":[ "subclassof" ], "to_name":[ "结构体" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "在定义结构体变量时,可以对它初始化，即赋予初始值。然后可以引用这个变量,例如输出它的成员的值。" ] }, "结构体":{ "key":[ "结构体" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 9 ], "知识点描述":[ "在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。" ] }, "建立动态链表":{ "key":[ "建立动态链表" ], "property":[ "subclassof" ], "to_name":[ "链表" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "所谓建立动态链表是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输人各结点数据,并建立起前后相链的关系。" ] }, "链表":{ "key":[ "链表" ], "property":[ "同义关系" ], "to_name":[ "结构体" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。" ] }, "条件运算符":{ "key":[ "条件运算符" ], "property":[ "前驱关系" ], "to_name":[ "条件表达式" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "表达式为：表达式1？表达式2：表达式3" ] }, "条件表达式":{ "key":[ "条件表达式" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 3 ], "所属章节":[ 11 ], "知识点描述":[ "其形式为：逻辑表达式?表达式1:表达式2  ；逻辑表达式的值若为非零,则条件表达式的值等于表达式1的值;若逻辑表达式的值为零,则条件表达式的值等于表达式2的值。" ] }, "强制类型转换":{ "key":[ "强制类型转换" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 3 ], "所属章节":[ 11 ], "知识点描述":[ "用“(类型)”运算符使表达式的类型进行强制转换，如(float)a。" ] }, "字符常量":{ "key":[ "字符常量" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 4 ], "所属章节":[ 11 ], "知识点描述":[ "用单撇号括起来的一个字符,可以使用转义字符。" ] }, "整型常量":{ "key":[ "整型常量" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 3 ], "所属章节":[ 11 ], "知识点描述":[ "十进制常数；八进制常数(以0开头的数字序列)；十六进制常数(以0x开头的数字序列)；长整型常数(在数字后加字符L或I)。" ] }, "赋值表达式":{ "key":[ "赋值表达式" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 4 ], "所属章节":[ 11 ], "知识点描述":[ "将赋值号“=”右侧表达式的值赋给赋值号左边的变量。赋值表达式的值为执行赋值后被赋值的变量的值。" ] }, "算术表达式":{ "key":[ "算术表达式" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 4 ], "所属章节":[ 11 ], "知识点描述":[ "整型表达式:参加运算的运算量是整型量,结果也是整型数。实型表达式:参加运算的运算量是实型量,运算过程中先转换成double型,结果为double型。" ] }, "逻辑运算符":{ "key":[ "逻辑运算符" ], "property":[ "同义关系" ], "to_name":[ "关系运算符" ], "重要程度":[ 5 ], "所属章节":[ 4 ], "知识点描述":[ "基本的操作符有：“非”（¬）、“与”（∧）、“或”（∨）、“条件”（→）以及“双条件”（?）。" ] }, "逻辑表达式":{ "key":[ "逻辑表达式" ], "property":[ "subclassof" ], "to_name":[ "关系运算符" ], "重要程度":[ 4 ], "所属章节":[ 11 ], "知识点描述":[ "用逻辑运算符连接的整型量,结果为-一个整数(0或1)。逻辑表达式可以认为是整型表达式的一种特殊形式。" ] }, "算法的描述方法":{ "key":[ "算法的描述方法" ], "property":[ "同义关系" ], "to_name":[ "算法的特征" ], "重要程度":[ 5 ], "所属章节":[ 2 ], "知识点描述":[ "描述算法的方法有多种，常用的有自然语言、结构化流程图、伪代码和PAD图等。" ] }, "算法的特征":{ "key":[ "算法的特征" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "有穷性；确切性；输入项；输出项；可行性" ] }, "关系运算符":{ "key":[ "关系运算符" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 5 ], "所属章节":[ 4 ], "知识点描述":[ "关系运算符有6种关系，分别为<小于、>大于、<=小于等于、>=大于等于、=等于、!=不等于。" ] }, "Java语言基础":{ "key":[ "Java语言基础" ], "property":[ "subclassof" ], "to_name":[ "Java" ], "重要程度":[ 4 ], "所属章节":[ "1~5" ], "知识点描述":[ "Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。一个Java程序的基本结构大体可以分为包、类、main()主方法、标识符、关键字、语句和注释等。" ] }, "Java面向对象":{ "key":[ "Java面向对象" ], "property":[ "subclassof" ], "to_name":[ "Java" ], "重要程度":[ 3 ], "所属章节":[ "6~11" ], "知识点描述":[ "面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。" ] }, "字符串":{ "key":[ "字符串" ], "property":[ "subclassof" ], "to_name":[ "Java语言基础" ], "重要程度":[ 4 ], "所属章节":[ "4、10" ], "知识点描述":[ "字符串是Java中特殊的类,使用方法像一般的基本数据类型，被广泛应用在 Java编程中。" ] }, "StringBuilder类":{ "key":[ "StringBuilder类" ], "property":[ "subclassof" ], "to_name":[ "字符串" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "StringBuilder类每次操作都是对自身对象进行操作，而不是生成新的对象，其所占空间会随着内容的增加而扩充，这样，在做大量的修改操作时，不会因生成大量匿名对象而影响系统性能。" ] }, "命令行参数":{ "key":[ "命令行参数" ], "property":[ "subclassof" ], "to_name":[ "字符串" ], "重要程度":[ 4 ], "所属章节":[ "1" ], "知识点描述":[ "java命令行参数是一个参数,即在运行java程序时传递的参数。从控制台传递的参数可以在java程序中接收,并且可以用作输入。" ] }, "格式化输出":{ "key":[ "格式化输出" ], "property":[ "subclassof" ], "to_name":[ "字符串" ], "重要程度":[ 4 ], "所属章节":[ "1" ], "知识点描述":[ "（1）一般方式：System.out.println('x = ' + x + ', y = ' + y);（2）printf()方式：System.out.printf('x = %d, y = %f\n', x, y);（3）format()方式：System.out.format('x = %d, y = %f\n', x, y)。" ] }, "循环结构":{ "key":[ "循环结构" ], "property":[ "type" ], "to_name":[ "Java语言基础" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次，就需要使用循环结构。Java中有三种主要的循环结构：while 循环、do…while循环、for 循环" ] }, "选择结构":{ "key":[ "选择结构" ], "property":[ "type" ], "to_name":[ "Java语言基础" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "选择结构是指选择某一条件后，才能决定下一步做什么。" ] }, "数组":{ "key":[ "数组" ], "property":[ "subclassof" ], "to_name":[ "Java语言基础" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "Java语言中提供的数组是用来存储固定大小的同类型元素。" ] }, "数据类型":{ "key":[ "数据类型" ], "property":[ "subclassof" ], "to_name":[ "Java语言基础" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "基本数据类型：（1）数值型：整型、浮点型、字符型：char、布尔型：boolean（2）引用数据类型：类（class）、接口（interface）、数组（[]）" ] }, "运算符":{ "key":[ "运算符" ], "property":[ "subclassof" ], "to_name":[ "Java语言基础" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：算术运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、其他运算符。" ] }, "String类":{ "key":[ "String类" ], "property":[ "subclassof" ], "to_name":[ "字符串" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "字符串广泛应用在Java编程中，在Java中字符串属于对象，Java提供了String类来创建和操作字符串。" ] }, "创建对象":{ "key":[ "创建对象" ], "property":[ "subclassof" ], "to_name":[ "String类" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "Java中String是一个特殊的包装类数据有两种创建形式：（1）String s = 'abc';（2）String s = new String('abc');    " ] }, "String类常用操作":{ "key":[ "String类常用操作" ], "property":[ "subclassof" ], "to_name":[ "String类" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "在Java中字符串属于对象，Java提供了 String类来创建和操作字符串。" ] }, "大小比较":{ "key":[ "大小比较" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "int compareTo(String anotherString) 按字典顺序比较两个字符串。" ] }, "拆分":{ "key":[ "拆分" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "String split(String regex)将字符串以regex拆分成数组。" ] }, "查找":{ "key":[ "查找" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "（1）int indexOf(String str) ：返回第一次出现的指定子字符串在此字符串中的索引。（2）int indexOf(String str, int startIndex)：从指定的索引处开始，返回第一次出现的指定子字符串在此字符串中的索引。（3）int lastIndexOf(String str) ：返回在此字符串中最右边出现的指定子字符串的索引。（4）int lastIndexOf(String str, int startIndex) ：从指定的索引处开始向后搜索，返回在此字符串中最后一次出现的指定子字符串的索引。" ] }, "求子串":{ "key":[ "求子串" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "Java String类中的substring()方法实现对字符串从指定的索引位置开始截取,直到此字符串的末尾,并返回一个新的字符串。" ] }, "求长度":{ "key":[ "求长度" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "使用数组属性length来获取数组长度，即 array.length。" ] }, "相等比较":{ "key":[ "相等比较" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "（1）equals：比较两个String对象的值是否相等；（2）= =：比较两个String对象的指向的内存地址是否相等。" ] }, "组合":{ "key":[ "组合" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "要么选择长度为n的字符串中的第一个字符，那么要在其余的长度n-1的字符串中选择m-1个字符；要么不选择长度为n的字符串中的第一个字符，那么要在其余的长度n-1的字符串中选择m个字符。" ] }, "转数组":{ "key":[ "转数组" ], "property":[ "subclassof" ], "to_name":[ "String类常用操作" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "string.toCharArray()" ] }, "变量":{ "key":[ "变量" ], "property":[ "subclassof" ], "to_name":[ "数据类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "Java中的变量:1、成员变量(实例变量,属性)2、本地变量(局部变量)3、类变量(静态属性)。" ] }, "关键字":{ "key":[ "关键字" ], "property":[ "subclassof" ], "to_name":[ "变量" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "Java的关键字对Java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。" ] }, "变量三要素":{ "key":[ "变量三要素" ], "property":[ "subclassof" ], "to_name":[ "变量" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "变量的三要素:变量类型、变量名字和变量值。" ] }, "标识符":{ "key":[ "标识符" ], "property":[ "subclassof" ], "to_name":[ "变量" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "Java语言中，对于变量，常量，函数，语句块也有名字，我们统统称之为Java标识符。标识符是用来给类、对象、方法、变量、接口和自定义数据类型命名的。" ] }, "变量的基本类型":{ "key":[ "变量的基本类型" ], "property":[ "subclassof" ], "to_name":[ "变量" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "Java语言支持的变量类型有局部变量、实例变量、类变量。" ] }, "单浮点型":{ "key":[ "单浮点型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "单精度浮点数在机内占4个字节、有效数字8位、表示范围：-3.40E+38 ~ +3.40E+38" ] }, "双浮点型":{ "key":[ "双浮点型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "double数据类型使用64位来存储浮点数。double值也称为双精度浮点数。它可以表示数量小到4.9 x 10-324和大到1.7 x 10308大小。它可以是正的或负的。所有实数被称为双精度字面量。双精度字面量可以可选地以d或D结尾，例如1.27d。" ] }, "字符型":{ "key":[ "字符型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "char数据类型是16位无符号Java基元数据类型。它表示Unicode字符。请注意，char是无符号数据类型。因此，char变量不能为负值。字符数据类型的范围为0到65535，这与Unicode集的范围相同。" ] }, "字节型":{ "key":[ "字节型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "字节数据类型是8位有符号Java原语整数数据类型。其范围为-128至127，字节类型是Java中可用的最小整数数据类型。" ] }, "布尔型":{ "key":[ "布尔型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "布尔数据类型只有两个有效值:true和false。这两个值称为布尔值字面量。" ] }, "整型":{ "key":[ "整型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "int数据类型是32位有符号Java原语数据类型。int数据类型的变量需要32位内存。其有效范围为-2,147,483,648至2,147,483,647（-231至231 - 1）。" ] }, "短整型":{ "key":[ "短整型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "short数据类型是16位有符号Java原语整数数据类型。 其范围是-32768至32767(或-2 15 15 - 1)。没有short字面量。但是，我们可以将任何位于short（-32768到32767）范围内的int字面量分配给一个短变量。" ] }, "长整型":{ "key":[ "长整型" ], "property":[ "type" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "long数据类型是64位有符号Java原始数据类型。当对整数的计算结果可能超出int数据类型的范围时使用。其范围是 -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807。" ] }, "数据类型转换":{ "key":[ "数据类型转换" ], "property":[ "subclassof" ], "to_name":[ "数据类型" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "数据类型的转换，分为自动转换和强制转换。自动转换是程序在执行过程中“悄然”进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。" ] }, "强制类型转换":{ "key":[ "强制类型转换" ], "property":[ "subclassof" ], "to_name":[ "数据类型转换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "强制类型转换是指：强制显示的把一个数据类型转换为另外一种数据类型。" ] }, "自动类型转换":{ "key":[ "自动类型转换" ], "property":[ "subclassof" ], "to_name":[ "数据类型转换" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。" ] }, "读取键盘输入":{ "key":[ "读取键盘输入" ], "property":[ "subclassof" ], "to_name":[ "数据类型" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "Scanner类不仅可以读取键盘输入值，也可以读取文件内容，只需要将构造方法中的数据来源切换成该文件即可。" ] }, "创建scanner对象":{ "key":[ "创建scanner对象" ], "property":[ "subclassof" ], "to_name":[ "读取键盘输入" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "Scanner sc = new Scanner(System.in);" ] }, "调入scanner类":{ "key":[ "调入scanner类" ], "property":[ "subclassof" ], "to_name":[ "读取键盘输入" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "import java.util.Scanner;" ] }, "调用next方法":{ "key":[ "调用next方法" ], "property":[ "subclassof" ], "to_name":[ "读取键盘输入" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。Java 语言中提供的数组是用来存储固定大小的同类型元素。" ] }, "数组的基本操作":{ "key":[ "数组的基本操作" ], "property":[ "subclassof" ], "to_name":[ "数组" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "java.util包的Arrays类里面包含了用来操作数组(如排序和搜索)的各种方法。" ] }, "使用数组":{ "key":[ "使用数组" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，所以索引的范围就是0 ~ 数组长度-1。在 Java 中提供有一种动态取得数组长度的方式：数组名称.length。" ] }, "元素复制":{ "key":[ "元素复制" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "（1）将数组元素逐个复制到目标数组中；（2）使用System类的arraycopy()方法；（3）使用Arrays类的copyOf()方法和copyOfRange()方法。" ] }, "元素迭代":{ "key":[ "元素迭代" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "Java集合类中的 List.iterator()方法用于返回按适当顺序在列表的元素上进行迭代的迭代器。方法返回值为 Iterator对象。" ] }, "创建数组":{ "key":[ "创建数组" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "Java语言使用new操作符来创建数组，语法如下：arrayRefVar = new dataType[arraySize];" ] }, "删除":{ "key":[ "删除" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "Java 的数组是固定长度的，无法直接删除，我们可以通过创建一个新数组，把原始数组中要保留的元素放到新数组中即可。" ] }, "反转":{ "key":[ "反转" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "（1）使用集合个工具类：Collections.reverse(ArrayList) 将数组进行反转；（2）使用集合ArrayList实现反转：（3）直接使用数组实现反转，即，反转后数组的第一个元素等于源数组的最后一个元素：" ] }, "取字符":{ "key":[ "取字符" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "（1）使用Java类库中的方法System.arraycopy；（2）使用Java类库中的方法 java.util.Arrays.copyOf；（3）重写myCopy" ] }, "插入":{ "key":[ "插入" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "（1）定义一个ArrayList数组，然后用add(element)方法往里添加元素，还可add(index,element)往指定下标处添加元素；（2）先把array转化为list，用list的add()方法添加元素，再把list转化为array；（3）创建一个新数组，新数组的大小为旧数组大小+1，把旧数组里的元素copy一份进新数组，并把要添加的元素添加进新数组。" ] }, "改字符":{ "key":[ "改字符" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "JAVA中替换字符的方法replace和replaceAll。" ] }, "数组排序":{ "key":[ "数组排序" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "Arrays.sort()排序方法在java中是最简单且最常用的排序方法，其他排序方法还有冒泡排序、插入排序、选择排序等。" ] }, "冒泡排序":{ "key":[ "冒泡排序" ], "property":[ "subclassof" ], "to_name":[ "数组排序" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "简单来说，冒泡排序就是重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。" ] }, "插入排序":{ "key":[ "插入排序" ], "property":[ "subclassof" ], "to_name":[ "数组排序" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。" ] }, "选择排序":{ "key":[ "选择排序" ], "property":[ "subclassof" ], "to_name":[ "数组排序" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "先找到最小元素所在位置的索引，然后将该元素与第一位上的元素进行交换。" ] }, "求容量":{ "key":[ "求容量" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "即计算Java数组的内存大小。" ] }, "追加":{ "key":[ "追加" ], "property":[ "subclassof" ], "to_name":[ "数组的基本操作" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "首先创建一个比原来数组长度大的临时数组，然后将原来数组中的元素一一复制到临时数组，接着将需要添加的新元素添加到最后的索引位置，最后将临时数组地址指针引用赋值给原数组即可。" ] }, "数组的基本类型":{ "key":[ "数组的基本类型" ], "property":[ "前驱关系" ], "to_name":[ "变量的基本类型" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ ] }, "一维数组":{ "key":[ "一维数组" ], "property":[ "前驱关系" ], "to_name":[ "多维数组" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ "当数组中每个元素都只带有一个下标时,这种数组就是一维数组。一维数组(one-dimensional array)实质上是一组相同类型数据的线性集合,是数组中最简单的一种数组。" ] }, "多维数组":{ "key":[ "多维数组" ], "property":[ "subclassof" ], "to_name":[ "数组的基本类型" ], "重要程度":[ 3 ], "所属章节":[ "8" ], "知识点描述":[ "多维数组(multidimensional array)的维数大于1。多维数组可以理解为“数组的数组” 。" ] }, "位运算符":{ "key":[ "位运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "位运算符主要针对二进制,它包括了:“与”、“非”、“或”、“异或”。" ] }, "位逻辑":{ "key":[ "位逻辑" ], "property":[ "type" ], "to_name":[ "位运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "位逻辑运算通常是针对两个数而言,实行位操作;而条件逻辑运算是针对两个条件表达式而言,实行条件操作。" ] }, "按位与":{ "key":[ "按位与" ], "property":[ "type" ], "to_name":[ "位逻辑" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "与运算符用符号“&”表示，其使用规律如下：两个操作数中位都为1，结果才为1，否则结果为0。" ] }, "按位取反":{ "key":[ "按位取反" ], "property":[ "type" ], "to_name":[ "位逻辑" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "非运算符用符号“~”表示，其运算规律如下：如果位为0，结果是1，如果位为1，结果是0。" ] }, "按位异或":{ "key":[ "按位异或" ], "property":[ "type" ], "to_name":[ "位逻辑" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "异或运算符是用符号“^”表示的，其运算规律是：两个操作数的位中，相同则结果为0，不同则结果为1。" ] }, "按位或":{ "key":[ "按位或" ], "property":[ "type" ], "to_name":[ "位逻辑" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "或运算符用符号“|”表示，其运算规律如下：两个位只要有一个为1，那么结果就是1，否则就为0。" ] }, "移位":{ "key":[ "移位" ], "property":[ "type" ], "to_name":[ "位运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "java中有三种移位运算符（1）<<: 左移运算符，num << 1,相当于num乘以2；（2）>>: 右移运算符，num >> 1,相当于num除以2；（3）>>>: 无符号右移，忽略符号位，空位都以0补齐。" ] }, "关系运算符":{ "key":[ "关系运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "关系运算符(relational operators)也可以称为“比较运算符 ”，用于用来比较判断两个变量或常量的大小。" ] }, "算术运算符":{ "key":[ "算术运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "算术运算符主要用于进行基本的算术运算，如加法、减法、乘法、除法等。" ] }, "赋值运算符":{ "key":[ "赋值运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "赋值运算符是指为变量或常量指定数值的符号。如可以使用 “=” 将右边的表达式结果赋给左边的操作数。" ] }, "逻辑运算符":{ "key":[ "逻辑运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "（1）&和&&：当且仅当 a、b 都为 true 时，结果为 true ；（2）| 和 || ：当且仅当 a、b 都为 false 时，结果为 false ；（3）^ : a 与 b 相异时，结果为 true " ] }, "if结构":{ "key":[ "if结构" ], "property":[ "type" ], "to_name":[ "选择结构" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "一个 if 语句包含一个布尔表达式和一条或多条语句。如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码。" ] }, "switch结构":{ "key":[ "switch结构" ], "property":[ "type" ], "to_name":[ "选择结构" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。" ] }, "do while循环":{ "key":[ "do while循环" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。" ] }, "for循环":{ "key":[ "for循环" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "虽然所有循环结构都可以用 while 或者 do...while表示，但 Java 提供了另一种语句——for 循环，使一些循环结构变得更加简单。for循环执行的次数是在执行前就确定的。" ] }, "while循环":{ "key":[ "while循环" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "while是最基本的循环，只要布尔表达式为 true，循环就会一直执行下去。" ] }, "增强for循环":{ "key":[ "增强for循环" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ "增强for循环是for循环的一种，简化了数组和集合的遍历，可以用来替代迭代器增强型for循环定义如下：for(ElementType element: arrayName){};" ] }, "循环中嵌套循环":{ "key":[ "循环中嵌套循环" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ "如果把一个循环放在另一个循环体内，那么就可以形成嵌套循环。" ] }, "无限循环":{ "key":[ "无限循环" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ "无限循环有for（；；）、while（true）、for（；true；）" ] }, "跳转语句":{ "key":[ "跳转语句" ], "property":[ "type" ], "to_name":[ "循环结构" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ "Java 支持 3 种跳转语句：break，continue 和return 。" ] }, "匿名内部类":{ "key":[ "匿名内部类" ], "property":[ "type" ], "to_name":[ "内部类" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。" ] }, "局部内部类":{ "key":[ "局部内部类" ], "property":[ "type" ], "to_name":[ "内部类" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。" ] }, "成员内部类":{ "key":[ "成员内部类" ], "property":[ "type" ], "to_name":[ "内部类" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "成员内部类是最普通的内部类，它的定义为位于另一个类的内部。成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。" ] }, "静态内部类":{ "key":[ "静态内部类" ], "property":[ "type" ], "to_name":[ "内部类" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法。" ] }, "成员":{ "key":[ "成员" ], "property":[ "subclassof" ], "to_name":[ "接口" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "Java的基本单位是类，Java成员即类中的成员，包括以下五个部分：变量、方法、构造器、初始化块、内部类。" ] }, "常量":{ "key":[ "常量" ], "property":[ "subclassof" ], "to_name":[ "成员" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "所谓常量可以理解成一种特殊的变量,它的值被设定后,在程序运行过程中不允许被改变。final 常量名=值; " ] }, "抽象方法":{ "key":[ "抽象方法" ], "property":[ "subclassof" ], "to_name":[ "成员" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "用abstract修饰的方法，即抽象方法。" ] }, "静态方法":{ "key":[ "静态方法" ], "property":[ "subclassof" ], "to_name":[ "成员" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中。" ] }, "默认方法":{ "key":[ "默认方法" ], "property":[ "subclassof" ], "to_name":[ "成员" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "默认方法是在接口中的方法签名前加上了default 关键字的实现方法。" ] }, "枚举类型":{ "key":[ "枚举类型" ], "property":[ "subclassof" ], "to_name":[ "接口" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，用于定义变量，以限制变量的赋值。" ] }, "泛型与集合":{ "key":[ "泛型与集合" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "19、21" ], "知识点描述":[ "所有集合类都位于java.util包中，集合中只能保存对象的引用。集合类把它所含有的元素看成是Object的实例，这样方便但是也有隐患，即多个类型不同的元素被放入一个集合中，会增加集合访问时类型转换的困难，甚至会产生错误。泛型的引入改善了这种情况，使用泛型来限制集合里元素的类型，并让集合记住元素的类型。这样可以允许编译器检查加入集合的元素类型，避免值类型不一致的错误。" ] }, "Collection":{ "key":[ "Collection" ], "property":[ "type" ], "to_name":[ "集合" ], "重要程度":[ 2 ], "所属章节":[ "19" ], "知识点描述":[ "Java使用集合来组织和管理对象。" ] }, "List":{ "key":[ "List" ], "property":[ "type" ], "to_name":[ "集合" ], "重要程度":[ 2 ], "所属章节":[ "19" ], "知识点描述":[ "List代表有序、可重复集合。" ] }, "Map":{ "key":[ "Map" ], "property":[ "type" ], "to_name":[ "集合" ], "重要程度":[ 2 ], "所属章节":[ "19" ], "知识点描述":[ "Map代表具有映射关系元素的集合。" ] }, "queue":{ "key":[ "queue" ], "property":[ "type" ], "to_name":[ "集合" ], "重要程度":[ 2 ], "所属章节":[ "19" ], "知识点描述":[ "Queue代表队列，实现元素的先进先出管理。" ] }, "Set":{ "key":[ "Set" ], "property":[ "type" ], "to_name":[ "集合" ], "重要程度":[ 2 ], "所属章节":[ "19" ], "知识点描述":[ "Set代表无序、不可重复集合。" ] }, "Stream_API":{ "key":[ "Stream_API" ], "property":[ "type" ], "to_name":[ "集合" ], "重要程度":[ 2 ], "所属章节":[ "19" ], "知识点描述":[ "三种常用API：（1）集合-->Stream：stream()；（2）数组-->Stream：Stream.of(T t)或者Arrays.stream(T[] t)；（3）任意元素-->Stream：Stream.of(T... values)" ] }, "泛型":{ "key":[ "泛型" ], "property":[ "type" ], "to_name":[ "泛型与集合" ], "重要程度":[ 2 ], "所属章节":[ "21" ], "知识点描述":[ "泛型允许在定义类、接口和方法时使类型（类、接口）成为参数，声明的类型参数在使用时用具体的类型替换。泛型主要应用在集合框架中。" ] }, "注解类型":{ "key":[ "注解类型" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。" ] }, "类和对象":{ "key":[ "类和对象" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "类是用来描述实体的“模板”或者原型；对象是实际的实体，每一个对象都是类的一个具体实例。" ] }, "内部类":{ "key":[ "内部类" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。" ] }, "多态":{ "key":[ "多态" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "11" ], "知识点描述":[ "指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。" ] }, "输入/输出":{ "key":[ "输入/输出" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "10" ], "知识点描述":[ "输入流只能进行读操作，输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。InputStream 是所有的输入字节流的父类，它是一个抽象类。OutputStream 是所有的输出字节流的父类，它也是一个抽象类。" ] }, "继承":{ "key":[ "继承" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "11" ], "知识点描述":[ "继承是一种连接类的层次模型，继承的目的在于鼓励重用。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的。" ] }, "继承的实现":{ "key":[ "继承的实现" ], "property":[ "subclassof" ], "to_name":[ "继承" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "继承描述的是一种能力：可以使用现有类的所有功能，并在无需重新编写原有类的情况下进行功能上的扩展。要使用继承，必须满足 is-a 原则(代码复用)，定义的语法为：子类 extends 父类。其中，子类：又称为派生类，子类一定具有父类的全部属性与行为，并且拥有的属性更多，具有的行为更加丰富，表示的范围更小。父类：又称为超类。" ] }, "异常处理":{ "key":[ "异常处理" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。Java的异常处理本质上是抛出异常和捕获异常。" ] }, "接口":{ "key":[ "接口" ], "property":[ "subclassof" ], "to_name":[ "Java面向对象" ], "重要程度":[ 2 ], "所属章节":[ "13" ], "知识点描述":[ "接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。" ] }, "final关键字":{ "key":[ "final关键字" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。" ] }, "super关键字":{ "key":[ "super关键字" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "java中的super关键字是一个引用变量,用于引用直接父类对象。" ] }, "使用类":{ "key":[ "使用类" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "类是对某一类事物的描述，是抽象的、概念上的意义，对象是实际存在的该类事物的每一个个体，也被称为实例。使用一个类，其实就是使用该类的成员(成员变量和成员方法)。" ] }, "包与类的导入":{ "key":[ "包与类的导入" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "导入（import），使用在同一个包下的类不需要导入可以直接用，使用不同的包下的类才需要导入。" ] }, "对象初始化和销毁":{ "key":[ "对象初始化和销毁" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "java对象初始化与对象销毁的顺序的相反的。" ] }, "抽象类":{ "key":[ "抽象类" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。" ] }, "方法覆盖":{ "key":[ "方法覆盖" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "方法覆盖（Overriding）是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。" ] }, "方法重载":{ "key":[ "方法重载" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "方法重载（Overloading）发生在同一个类里面两个或者多个方法的方法名相同但是参数不同的情况。" ] }, "类体":{ "key":[ "类体" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "类体中包括成员变量的声明和方法的定义，成员变量又分为实例变量和类变量，定义的方法可分为实例方法和类方法。" ] }, "类声明":{ "key":[ "类声明" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "声明一个类需要通过一个关键字class。" ] }, "访问修饰符":{ "key":[ "访问修饰符" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：（1）public（2）protected（3）default（4）private：" ] }, "静态成员":{ "key":[ "静态成员" ], "property":[ "subclassof" ], "to_name":[ "类和对象" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "静态成员是一组比较特殊的成员，它不属于某个特定的类实例，而是属于一个类所有，这个类的所有实例共享它们。类的静态成员，指的是用static修饰的成员，主要有三种：静态变量、静态方法和静态代码块。" ] }, "类":{ "key":[ "类" ], "property":[ "subclassof" ], "to_name":[ "多态" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。类是一种用户定义的引用数据类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象。" ] }, "对象":{ "key":[ "对象" ], "property":[ "subclassof" ], "to_name":[ "多态" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "对象是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。类是一系列事物的统称，对象就是类具体化的实例" ] }, "多态":{ "key":[ "多态" ], "property":[ "subclassof" ], "to_name":[ "抽象" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "面向对象(Object Oriented)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物" ] }, "封装":{ "key":[ "封装" ], "property":[ "subclassof" ], "to_name":[ "抽象" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "将数据隐藏起来，隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对数据属性操作的严格控制。" ] }, "继承":{ "key":[ "继承" ], "property":[ "subclassof" ], "to_name":[ "抽象" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。" ] }, "抽象":{ "key":[ "抽象" ], "property":[ "subclassof" ], "to_name":[ "面向对象" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "抽象类是一个特殊的类，只能被继承，不能实例化" ] }, "模块":{ "key":[ "模块" ], "property":[ "subclassof" ], "to_name":[ "面向对象" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "一个.py文件就是一个模块。" ] }, "函数":{ "key":[ "函数" ], "property":[ "subclassof" ], "to_name":[ "面向对象" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。" ] }, "异常":{ "key":[ "异常" ], "property":[ "subclassof" ], "to_name":[ "面向对象" ], "重要程度":[ 4 ], "所属章节":[ 6 ], "知识点描述":[ "程序在运行时，如果Python 解释器遇到到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常" ] }, "内建函数":{ "key":[ "内建函数" ], "property":[ "type" ], "to_name":[ "函数" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "内建函数是python解释器内置的函数，由cpython执行的c语言编写的函数，在加载速度上优于开发者自定义的函数" ] }, "随机函数":{ "key":[ "随机函数" ], "property":[ "type" ], "to_name":[ "函数" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "Python中的 random模块用于生成随机数，它提供了很多函数" ] }, "面向对象":{ "key":[ "面向对象" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "面向对象是一种编程思想，是对现实世界中一类事物的抽象，在编程中可以理解为是一种建立现实世界事物的模型" ] }, "高级应用":{ "key":[ "高级应用" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ ] }, "异步编程":{ "key":[ "异步编程" ], "property":[ "subclassof" ], "to_name":[ "高级应用" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "以进程、线程、协程、函数/方法作为执行任务程序的基本单位，结合回调、事件循环、信号量等机制，以提高程序整体执行效率和并发能力的编程方式。" ] }, "网络爬虫":{ "key":[ "网络爬虫" ], "property":[ "subclassof" ], "to_name":[ "高级应用" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ "网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。这是百度百科对爬虫的定义，其实，说简单点，爬虫就是利用写好的程序自动的提取网页的信息。" ] }, "闭包":{ "key":[ "闭包" ], "property":[ "subclassof" ], "to_name":[ "高级应用" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。" ] }, "装饰器":{ "key":[ "装饰器" ], "property":[ "subclassof" ], "to_name":[ "高级应用" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "装饰器是一种特殊的函数，它输入一个函数输出一个函数，可用于给一个函数附加一些功能" ] }, "文件":{ "key":[ "文件" ], "property":[ "subclassof" ], "to_name":[ "高级应用" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "计算机的文件，就是存储在某种长期储存设备上的一段数据" ] }, "Lambda表达式":{ "key":[ "Lambda表达式" ], "property":[ "subclassof" ], "to_name":[ "高级应用" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "Lambda 表达式（lambda expression）是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。" ] }, "语言基础":{ "key":[ "语言基础" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ ] }, "输入输出":{ "key":[ "输入输出" ], "property":[ "subclassof" ], "to_name":[ "语言基础" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "输入输出（input/output，I/O），读作“eye-oh”，描述的是在计算机上输入输出数据的操作系统、程序或设备。" ] }, "数据类型":{ "key":[ "数据类型" ], "property":[ "subclassof" ], "to_name":[ "语言基础" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ ] }, "不可变类型":{ "key":[ "不可变类型" ], "property":[ "type" ], "to_name":[ "数据类型" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。" ] }, "容器类型":{ "key":[ "容器类型" ], "property":[ "type" ], "to_name":[ "数据类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。" ] }, "float":{ "key":[ "float" ], "property":[ "type" ], "to_name":[ "不可变类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "浮点型数据类型，FLOAT 数据类型用于存储单精度浮点数或双精度浮点数。" ] }, "complex":{ "key":[ "complex" ], "property":[ "type" ], "to_name":[ "不可变类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "复数类型，复数存放的是一对浮点数，一个表示实数部分，另一个表示虚数部分" ] }, "int":{ "key":[ "int" ], "property":[ "type" ], "to_name":[ "不可变类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "程序中用的最多是一般整数类型（简称“整数类型”或“整型”）和长整数类型（简称“长整型”），整数类型的类型名是“int”，长整型的类型名为“long int”,可简写为“long”，int和long都是关键字。" ] }, "bool":{ "key":[ "bool" ], "property":[ "type" ], "to_name":[ "不可变类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "bool表示布尔型变量，也就是逻辑型变量的定义符" ] }, "tuple":{ "key":[ "tuple" ], "property":[ "type" ], "to_name":[ "容器类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行" ] }, "sets":{ "key":[ "sets" ], "property":[ "type" ], "to_name":[ "容器类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "set是一个无序且不重复的元素集合" ] }, "string":{ "key":[ "string" ], "property":[ "type" ], "to_name":[ "容器类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "浮点型数据类型，FLOAT 数据类型用于存储单精度浮点数或双精度浮点数。" ] }, "list":{ "key":[ "list" ], "property":[ "type" ], "to_name":[ "容器类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "列表由一系列特定顺序排列的元素组成" ] }, "dictionary":{ "key":[ "dictionary" ], "property":[ "type" ], "to_name":[ "容器类型" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "字典是另一种可变容器模型，且可存储任意类型对象。" ] }, "程序控制结构":{ "key":[ "程序控制结构" ], "property":[ "subclassof" ], "to_name":[ "语言基础" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "程序控制方式是指在程序控制下进行的数据传递方式 [1]  。程序控制结构是指以某种顺序执行的一系列动作，用于解决某个问题" ] }, "循环结构":{ "key":[ "循环结构" ], "property":[ "type" ], "to_name":[ "程序控制结构" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环" ] }, "顺序结构":{ "key":[ "顺序结构" ], "property":[ "type" ], "to_name":[ "程序控制结构" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "顺序结构是最简单的程序结构，也是最常用的程序结构，它的执行顺序是自上而下，依次执行" ] }, "选择结构":{ "key":[ "选择结构" ], "property":[ "type" ], "to_name":[ "程序控制结构" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "选择结构用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。" ] }, "语句":{ "key":[ "语句" ], "property":[ "subclassof" ], "to_name":[ "语言基础" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "一个语法上自成体系的单位，它由一个词或句法上有关连的一组词构成，表达一种主张、疑问、命令、愿望或感叹。" ] }, "条件语句":{ "key":[ "条件语句" ], "property":[ "type" ], "to_name":[ "语句" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "条件语句是用来判断给定的条件是否满足(表达式值是否为0)，并根据判断的结果(真或假)决定执行的语句，选择结构就是用条件语句来实现的。" ] }, "循环语句":{ "key":[ "循环语句" ], "property":[ "type" ], "to_name":[ "语句" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。 [1]  循环语句是由循环体及循环的终止条件两部分组成的" ] }, "if语句":{ "key":[ "if语句" ], "property":[ "type" ], "to_name":[ "语句" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "if语句是指编程语言（包括c语言、C#、VB、java、汇编语言等）中用来判定所给定的条件是否满足，根据判定的结果（真或假）决定执行给出的两种操作之一。" ] }, "运算符":{ "key":[ "运算符" ], "property":[ "subclassof" ], "to_name":[ "语言基础" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算" ] }, "身份运算符":{ "key":[ "身份运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "判断是否引用自一个对象。主要是通过两个对象的存储单元id进行对比判断两个变量是否相同" ] }, "逻辑运算符":{ "key":[ "逻辑运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "用于逻辑运算的符号，一般用于判断两个变量的交并集。一般返回一个布尔值。" ] }, "成员运算符":{ "key":[ "成员运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "用于判断两个对象的是否存在包含关系，即一个对象中是否包含另外一个对象。其返回结尾为布尔值。" ] }, "赋值运算符":{ "key":[ "赋值运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "赋值运算符是编程开发中最常用的运算符，即对一个对象进行赋值，将运算符右侧的值赋值给左侧的变量。其中赋值运算符与算术运算符可以在为变量赋值时增加算术运算功能。" ] }, "算数运算符":{ "key":[ "算数运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "算术运算符主要是对两个对象进行算术计算的符号" ] }, "位运算符":{ "key":[ "位运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "位运算符是对Python对象进行按照存储的Bit操作。其运算对象是二进制的格式。" ] }, "比较运算符":{ "key":[ "比较运算符" ], "property":[ "type" ], "to_name":[ "运算符" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "对于两个对象进行比较（判断是否相同、大于或小于等运算），其运算对象可以是数值也可以是字符串。其结果返回布尔值" ] }, "缓冲区":{ "key":[ "缓冲区" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "缓冲区是内存的临时存储区域，它的出现是为了加快内存的访问速度而设计的。对于经常访问的数据和指令来说，CPU 应该访问的是缓冲区而非内存。" ] }, "DMA":{ "key":[ "DMA" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "直接内存访问，它是计算机系统的一项功能，它允许某些硬件系统能够独立于 CPU 访问内存。如果没有 DMA，当 CPU 执行输入/输出指令时，它通常在读取或写入操作的整个过程中都被完全占用，因此无法执行其他工作。使用 DMA 后，CPU 首先启动传输信号，然后在进行传输时执行其他操作，最后在完成操作后从 DMA 控制器（DMAC）接收中断。完成执行。" ] }, "MMU":{ "key":[ "MMU" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "内存管理单元，有时称作分页内存管理单元。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制等。" ] }, "ROM":{ "key":[ "ROM" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除，且内容不会因为电源关闭而消失。在电子或电脑系统中，通常用以存储不需经常变更的程序或数据。" ] }, "SSD":{ "key":[ "SSD" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "SSD(Solid State Disks)：固态硬盘，是一种主要以闪存作为永久性存储器的电脑存储设备。" ] }, "虚拟地址":{ "key":[ "虚拟地址" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "虚拟内存是计算机系统内存管理的一种机制。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。" ] }, "EEPROM":{ "key":[ "EEPROM" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "电可擦除可编程只读存储器，是一种可以通过电子方式多次复写的半导体存储设备。" ] }, "闪存":{ "key":[ "闪存" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性数据存储，以及在电脑与其他数字产品间交换传输数据，如储存卡与U盘。" ] }, "地址空间":{ "key":[ "地址空间" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 2 ], "所属章节":[ 6 ], "知识点描述":[ "地址空间是内存中可供程序或进程使用的有效地址范围。也就是说，它是程序或进程可以访问的内存。存储器可以是物理的也可以是虚拟的，用于执行指令和存储数据。" ] }, "稳定存储":{ "key":[ "稳定存储" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 4 ], "所属章节":[ 9 ], "知识点描述":[ "它是计算机存储技术的一种分类，该技术可确保任何给定的写操作都具有原子性。" ] }, "缓存命中":{ "key":[ "缓存命中" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "当应用程序或软件请求数据时，会首先发生缓存命中。首先，中央处理单元（CPU）在其最近的内存位置（通常是主缓存）中查找数据。如果在缓存中找到请求的数据，则将其视为缓存命中。" ] }, "高速缓存行":{ "key":[ "高速缓存行" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "其实就是把高速缓存分割成了固定大小的块，其大小是以突发读或者突发写周期的大小为基础的。" ] }, "RAID":{ "key":[ "RAID" ], "property":[ "subclassof" ], "to_name":[ "存储体系结构" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "全称是 Redundant Array of Inexpensive Disks ，廉价磁盘或驱动器的冗余阵列，它是一种数据存储虚拟化的技术，将多个物理磁盘驱动器组件组合成一个或多个逻辑单元，以实现数据冗余，改善性能。" ] }, "内存映射I/O":{ "key":[ "内存映射I/O" ], "property":[ "subclassof" ], "to_name":[ ". I/O port" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "内存映射的 I/O 使用相同的地址空间来寻址内存和 I/O 设备，也就是说，内存映射I/O 设备共享同一内存地址。" ] }, "端口映射I/O":{ "key":[ "端口映射I/O" ], "property":[ "subclassof" ], "to_name":[ ". I/O port" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "在 PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。" ] }, "显卡":{ "key":[ "显卡" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "是个人电脑最基本组成部分之一，用途是将计算机系统所需要的显示信息进行转换驱动显示器，并向显示器提供逐行或隔行扫描信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要组件，是人机对话的重要设备之一。" ] }, "位图":{ "key":[ "位图" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "在计算机中，位图是从某个域（例如，整数范围）到位的映射。也称为位数组或位图索引。" ] }, "QR Code":{ "key":[ "QR Code" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "二维码的一种，它的全称是快速响应矩阵图码，能够快速响应。一般应用于手机读码操作，国内火车票上的二维码就是 QR 码。" ] }, "假脱机":{ "key":[ "假脱机" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "假脱机是多程序的一种特殊形式，目的是在不同设备之间复制数据。 在现代系统中，通常用于计算机应用程序和慢速外围设备（例如打印机）之间的中介。" ] }, "电阻式触摸屏":{ "key":[ "电阻式触摸屏" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "电阻式触摸屏基于施加到屏幕上的压力来工作。电阻屏由许多层组成。当按下屏幕时，外部的后面板将被推到下一层，下一层会感觉到施加了压力并记录了输入。电阻式触摸屏用途广泛，可以用手指，指甲，手写笔或任何其他物体进行操作。" ] }, "电容式触摸屏":{ "key":[ "电容式触摸屏" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "电容式触摸屏通过感应物体（通常是指尖上的皮肤）的导电特性来工作。手机或智能手机上的电容屏通常具有玻璃表面，并且不依赖压力。当涉及到手势（如滑动和捏合）时，它比电阻式屏幕更具响应性。电容式触摸屏只能用手指触摸，而不能用普通的手写笔，手套或大多数其他物体来响应。" ] }, "逻辑块寻址":{ "key":[ "逻辑块寻址" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "逻辑块寻址是一种通用方案，用于指定存储在计算机存储设备上的数据块的位置。" ] }, "时钟":{ "key":[ "时钟" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "也被称为 timers。通常，时钟是指调节所有计算机功能的时序和速度的微芯片。芯片中是一个晶体，当通电时，晶体会以特定的频率振动。任何一台计算机能够执行的最短时间是一个时钟或时钟芯片的一次振动。" ] }, "主设备编号":{ "key":[ "主设备编号" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "所有设备都有一个主，副号码。主号码是更大，更通用的类别（例如硬盘，输入/输出设备等），而次号码则更具体（即告诉设备连接到哪条总线）。" ] }, "挂载":{ "key":[ "挂载" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "挂载是指操作系统会让存储在硬盘、CD-ROM 等资源设备上的目录和文件，通过文件系统能够让用户访问的过程。" ] }, "设备独立性":{ "key":[ "设备独立性" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 1 ], "所属章节":[ 8 ], "知识点描述":[ "我们编写访问任何设备的应用程序，不用事先指定特定的设备。比如你编写了一个能够从设备读入文件的应用程序，那么这个应用程序可以从硬盘、DVD 或者 USB 进行读入，不必再为每个设备定制应用程序。这其实就体现了设备独立性的概念。" ] }, ". I/O port":{ "key":[ ". I/O port" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "也被称为输入/输出端口，它是由软件用来与计算机上的硬件进行通信的内存地址。" ] }, "轮询":{ "key":[ "轮询" ], "property":[ "subclassof" ], "to_name":[ "设备控制器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "轮询是指通过客户端程序主动通过对每个设备进行访问来获得同步状态的过程。" ] }, "设备控制器":{ "key":[ "设备控制器" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "设备控制器是处理 CPU 传入信号和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。" ] }, "存储体系结构":{ "key":[ "存储体系结构" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。" ] }, "Java 虚拟机":{ "key":[ "Java 虚拟机" ], "property":[ "subclassof" ], "to_name":[ "虚拟机" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。" ] }, "云计算":{ "key":[ "云计算" ], "property":[ "subclassof" ], "to_name":[ "云" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "云计算是计算机系统资源（尤其是数据存储和计算能力）的按需可用性，而无需用户直接进行主动管理。这个术语通常用于描述 Internet 上可供许多用户使用的数据中心。如今占主导地位的大型云通常具有从中央服务器分布在多个位置的功能。如果与用户的连接相对较近，则可以将其指定为边缘服务器。" ] }, "半虚拟化":{ "key":[ "半虚拟化" ], "property":[ "subclassof" ], "to_name":[ "虚拟化技术" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "半虚拟化的目的不是呈现出一个和底层硬件一摸一样的虚拟机，而是提供一个软件接口，软件接口与硬件接口相似但又不完全一样。" ] }, "全虚拟化":{ "key":[ "全虚拟化" ], "property":[ "subclassof" ], "to_name":[ "虚拟化技术" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "全虚拟化是硬件虚拟化的一种，允许未经修改的客操作系统隔离运行。对于全虚拟化，硬件特征会被映射到虚拟机上，这些特征包括完整的指令集、I/O操作、中断和内存管理等。" ] }, "VMM":{ "key":[ "VMM" ], "property":[ "subclassof" ], "to_name":[ "虚拟化技术" ], "重要程度":[ 2 ], "所属章节":[ 10 ], "知识点描述":[ "也被称为 hypervisor，在同一个物理机器上创建出来多态虚拟机器的假象。" ] }, "云":{ "key":[ "云" ], "property":[ "subclassof" ], "to_name":[ "虚拟化技术" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "云是目前虚拟机最重要、最时髦的玩法。" ] }, "虚拟机":{ "key":[ "虚拟机" ], "property":[ "subclassof" ], "to_name":[ "虚拟化技术" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。" ] }, "虚拟化技术":{ "key":[ "虚拟化技术" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "是一种资源管理技术，将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），进行抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。" ] }, "工作目录":{ "key":[ "工作目录" ], "property":[ "subclassof" ], "to_name":[ "目录" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。" ] }, "根目录":{ "key":[ "根目录" ], "property":[ "subclassof" ], "to_name":[ "目录" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /" ] }, "路径":{ "key":[ "路径" ], "property":[ "subclassof" ], "to_name":[ "目录" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。" ] }, "文件描述符":{ "key":[ "文件描述符" ], "property":[ "subclassof" ], "to_name":[ "目录" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。" ] }, "目标文件":{ "key":[ "目标文件" ], "property":[ "subclassof" ], "to_name":[ "目录" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "目标文件是包含目标代码的文件，这意味着通常无法直接执行的可重定位格式的机器代码。目标文件有多种格式，相同的目标代码可以打包在不同的目标文件中。目标文件也可以像共享库一样工作。" ] }, "服务端":{ "key":[ "服务端" ], "property":[ "subclassof" ], "to_name":[ "主从架构" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备，称为服务端" ] }, "客户端":{ "key":[ "客户端" ], "property":[ "subclassof" ], "to_name":[ "主从架构" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "客户端是访问服务器提供的服务的计算机硬件或软件。" ] }, "主从模型":{ "key":[ "主从模型" ], "property":[ "subclassof" ], "to_name":[ "主从架构" ], "重要程度":[ 4 ], "所属章节":[ 11 ], "知识点描述":[ "主/从是一种不对称通信或控制的模型，其中一个设备进程控制一个或多个其他设备或进程并充当其通信中心。在某些系统中，从一组合格的设备中选择一个主设备，而其他设备则充当从设备的角色。" ] }, "用户模式":{ "key":[ "用户模式" ], "property":[ "subclassof" ], "to_name":[ "主从架构" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "当操作系统运行用户应用程序（例如处理文本编辑器）时，系统处于用户模式。当应用程序请求操作系统的帮助或发生中断或系统调用时，就会发生从用户模式到内核模式的转换。在用户模式下，模式位设置为1。从用户模式切换到内核模式时，它从1更改为0。" ] }, "内核模式":{ "key":[ "内核模式" ], "property":[ "subclassof" ], "to_name":[ "主从架构" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "通常也被称为 超级模式（supervisor mode），在内核模式下，正在执行的代码具有对底层硬件的完整且不受限制的访问。它可以执行任何 CPU 指令并引用任何内存地址。内核模式通常保留给操作系统的最低级别，最受信任的功能。内核模式下的崩溃是灾难性的；他们将停止整个计算机。超级用户模式是计算机开机时选择的自动模式。" ] }, "主从架构":{ "key":[ "主从架构" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "主从式架构也称客户端/服务器架构、C/S 架构，是一种网络架构，它把客户端与服务器区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、游戏服务器等。" ] }, "活锁":{ "key":[ "活锁" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "活锁类似于死锁，不同之处在于，活锁中仅涉及进程的状态彼此之间不断变化，没有进展。举一个现实世界的例子，当两个人在狭窄的走廊里相遇时，就会发生活锁，每个人都试图通过移动到一边让对方通过而礼貌，但最终却没有任何进展就左右摇摆，因为他们总是同时移动相同的方式。" ] }, "死锁":{ "key":[ "死锁" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 9 ], "知识点描述":[ "死锁常用于并发情况下，死锁 是一种状态，死锁中的每个成员都在等待另一个成员（包括其自身）采取行动。" ] }, "不可抢占资源":{ "key":[ "不可抢占资源" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 9 ], "知识点描述":[ "与可抢占资源相反，如果资源被抢占后，会导致进程或任务出错。" ] }, "可抢占资源":{ "key":[ "可抢占资源" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 9 ], "知识点描述":[ "可以从拥有它的进程中抢占而并不会产生任何副作用。" ] }, "异步响应":{ "key":[ "异步响应" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "异步是由中断驱动的，CPU 不用等待每个操作的处理结果继而执行其他操作" ] }, "同步阻塞":{ "key":[ "同步阻塞" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "同步是阻塞式的，CPU 必须等待同步的处理结果。" ] }, "错误处理":{ "key":[ "错误处理" ], "property":[ "subclassof" ], "to_name":[ "突发模式" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "错误处理是指对软件应用程序中存在的错误情况的响应和恢复过程。" ] }, "局域网":{ "key":[ "局域网" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 2 ], "所属章节":[ 11 ], "知识点描述":[ "局域网（LAN）是一种计算机网络，可将住宅，学校，实验室，大学校园或办公大楼等有限区域内的计算机互连。" ] }, "广域网":{ "key":[ "广域网" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 2 ], "所属章节":[ 11 ], "知识点描述":[ "又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。" ] }, "以太网":{ "key":[ "以太网" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 2 ], "所属章节":[ 11 ], "知识点描述":[ "以太网是一种计算机局域网的技术，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。" ] }, "桥接器":{ "key":[ "桥接器" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 2 ], "所属章节":[ 11 ], "知识点描述":[ "当指代计算机时，网桥是连接两个 LAN（局域网）或同一 LAN 的两个网段的设备。与路由器不同，网桥是独立于协议的。他们转发数据包时无需分析和重新路由消息。" ] }, "inode":{ "key":[ "inode" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "索引节点的缩写，索引节点是 UNIX 系统中包含的信息，其中包含有关每个文件的详细信息，例如节点，所有者，文件，文件位置等。" ] }, "周期窃取":{ "key":[ "周期窃取" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 1 ], "所属章节":[ 7 ], "知识点描述":[ "许多总线能够以两种模式操作：每次一字模式和块模式。一些 DMA 控制器也能够使用这两种方式进行操作。在前一个模式中，DMA 控制器请求传送一个字并得到这个字。如果 CPU 想要使用总线，它必须进行等待。设备可能会偷偷进入并且从 CPU 偷走一个总线周期，从而轻微的延迟 CPU。它类似于直接内存访问（DMA），允许I / O控制器在无需 CPU 干预的情况下读取或写入RAM。" ] }, "中断向量表":{ "key":[ "中断向量表" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 1 ], "所属章节":[ 8 ], "知识点描述":[ "用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址称为中断向量。中断向量表是中断向量的集合，中断向量是中断处理程序的地址。" ] }, "系统检查点":{ "key":[ "系统检查点" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 4 ], "所属章节":[ 9 ], "知识点描述":[ "系统检查点是操作系统（OS）的可启动实例。检查点是计算机在特定时间点的快照。" ] }, "命令行界面":{ "key":[ "命令行界面" ], "property":[ "subclassof" ], "to_name":[ "主机" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ "是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。" ] }, "中断向量":{ "key":[ "中断向量" ], "property":[ "subclassof" ], "to_name":[ "进程" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "中断向量位于中断向量表中。中断向量表（IVT）是将中断处理程序列表与中断向量表中的中断请求列表相关联的数据结构。中断向量表的每个条目（称为中断向量）都是中断处理程序的地址。" ] }, "主机":{ "key":[ "主机" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 2 ], "所属章节":[ 11 ], "知识点描述":[ "在网络硬件中，主机又被称为网络主机，网络主机是连接到计算机网络的计算机或其他设备。主机可以充当服务器，向网络上的用户或其他主机提供信息资源，服务和应用程序。主机被分配至少一个网络地址。" ] }, "大型机":{ "key":[ "大型机" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "大型机是一类计算机，通常以其大尺寸，存储量，处理能力和高度的可靠性而著称。它们主要由大型组织用于需要大量数据处理的关键任务应用程序。" ] }, "图形处理器":{ "key":[ "图形处理器" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "又称显示核心、视觉处理器、显示芯片或绘图芯片；它是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上运行绘图运算工作的微处理器。" ] }, "超级用户":{ "key":[ "超级用户" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ "也被称为管理员帐户，在计算机操作系统领域中指一种用于进行系统管理的特殊用户，其在系统中的实际名称也因系统而异，如 root、administrator 与supervisor。" ] }, "实时迁移":{ "key":[ "实时迁移" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 11 ], "知识点描述":[ "实时迁移是指在不断开客户端或应用程序连接的情况下，在不同的物理机之间移动正在运行的虚拟机或应用程序的过程，一般经常采用的方式是内存预复制迁移。" ] }, "进程间通信":{ "key":[ "进程间通信" ], "property":[ "subclassof" ], "to_name":[ "批处理" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ "指至少两个进程或线程间传送数据或信号的一些技术或方法。" ] }, "多线程":{ "key":[ "多线程" ], "property":[ "subclassof" ], "to_name":[ "批处理" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，进而提升整体处理性能。" ] }, "系统调用":{ "key":[ "系统调用" ], "property":[ "subclassof" ], "to_name":[ "批处理" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备 IO 操作或者进程间通信。" ] }, "忙等":{ "key":[ "忙等" ], "property":[ "subclassof" ], "to_name":[ "进程" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "在软件工程中，忙碌等待也称自旋，是一种以进程反复检查一个条件是否为真的条件，这种机制可能为检查键盘输入或某个锁是否可用。" ] }, "中断":{ "key":[ "中断" ], "property":[ "subclassof" ], "to_name":[ "进程" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为 CPU 指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。中断在计算机多任务处理，尤其是即时系统中尤为有用。" ] }, "进程表":{ "key":[ "进程表" ], "property":[ "subclassof" ], "to_name":[ "进程" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ "进程表是操作系统维护的数据结构，该表中的每个条目（通常称为上下文块）均包含有关进程的信息，例如进程名称和状态，优先级，寄存器以及它可能正在等待的信号灯。" ] }, "进程":{ "key":[ "进程" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ "程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步的方式独立运行。" ] }, "L1 cache":{ "key":[ "L1 cache" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "一级缓存是 CPU 芯片中内置的存储库。L1缓存也称为主缓存，是计算机中最快的内存，并且最接近处理器。" ] }, "L2 cache":{ "key":[ "L2 cache" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "二级缓存存储库，内置在 CPU 芯片中，包装在同一模块中，或者建在主板上。L2 高速缓存提供给 L1 高速缓存，后者提供给处理器。L2 内存比 L1 内存慢。" ] }, "L3 cache":{ "key":[ "L3 cache" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "三级缓存内置在主板上或CPU模块内的存储库。L3 高速缓存为 L2 高速缓存提供数据，其内存通常比 L2 内存慢，但比主内存快。L3 高速缓存提供给 L2 高速缓存，后者又提供给 L1 高速缓存，后者又提供给处理器。" ] }, "RAM":{ "key":[ "RAM" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与 ROM 的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM 在计算机和数字系统中用来暂时存储程序、数据和中间结果。" ] }, "context switch":{ "key":[ "context switch" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "上下文切换，又称环境切换。是一个存储和重建 CPU 状态的机制。要交换 CPU 上的进程时，必需先行存储当前进程的状态，然后再将进程状态读回 CPU 中。" ] }, "程序状态字":{ "key":[ "程序状态字" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "它是由操作系统维护的8个字节（或64位）长的数据的集合。它跟踪系统的当前状态。" ] }, "程序计数器":{ "key":[ "程序计数器" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置。" ] }, "超标量":{ "key":[ "超标量" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "超标量 CPU 架构是指在一颗处理器内核中实行了指令级并发的一类并发运算。这种技术能够在相同的CPU主频下实现更高的 CPU 流量。" ] }, "流水线":{ "key":[ "流水线" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "在计算世界中，管道是一组串联连接的数据处理元素，其中一个元素的输出是下一个元素的输入。流水线的元素通常以并行或按时间分割的方式执行。通常在元素之间插入一定数量的缓冲区存储。" ] }, "堆栈寄存器":{ "key":[ "堆栈寄存器" ], "property":[ "subclassof" ], "to_name":[ "CPU 核心" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "堆栈寄存器(stack pointer)：堆栈寄存器是计算机 CPU 中的寄存器，其目的是跟踪调用堆栈。" ] }, "CPU 核心":{ "key":[ "CPU 核心" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核。" ] }, "SATA":{ "key":[ "SATA" ], "property":[ "subclassof" ], "to_name":[ "总线(Bus)" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "串行 ATA (Serial Advanced Technology Attachment)，它是一种电脑总线，负责主板和大容量存储设备（如硬盘及光盘驱动器）之间的数据传输，主要用于个人电脑。" ] }, "总线(Bus)":{ "key":[ "总线(Bus)" ], "property":[ "subclassof" ], "to_name":[ "计算机架构" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "总线（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。" ] }, "X Window System":{ "key":[ "X Window System" ], "property":[ "subclassof" ], "to_name":[ "x86" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ " 窗口系统（X11，或简称X）是用于位图显示的窗口系统，在类 UNIX 操作系统上很常见。" ] }, "x86":{ "key":[ "x86" ], "property":[ "subclassof" ], "to_name":[ "计算机架构" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "x86是一整套指令集体系结构，由 Intel 最初基于 Intel 8086 微处理器及其 8088 变体开发。采用内存分段作为解决方案，用于处理比普通 16 位地址可以覆盖的更多内存。32 位是 x86 默认的位数，除此之外，还有一个 x86-64 位，是x86架构的 64 位拓展，向后兼容于 16 位及 32 位的 x86架构。" ] }, "计算机架构":{ "key":[ "计算机架构" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 1 ], "知识点描述":[ "在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构" ] }, "BSD":{ "key":[ "BSD" ], "property":[ "subclassof" ], "to_name":[ "UNIX 操作系统" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "UNIX 的衍生系统。" ] }, "MINIX":{ "key":[ "MINIX" ], "property":[ "subclassof" ], "to_name":[ "UNIX 操作系统" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "Minix，是一个迷你版本的类 UNIX 操作系统。" ] }, "POSIX":{ "key":[ "POSIX" ], "property":[ "subclassof" ], "to_name":[ "UNIX 操作系统" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "可移植操作系统接口，是 IEEE 为要在各种 UNIX 操作系统上运行软件，而定义API的一系列互相关联的标准的总称。" ] }, "UNIX System V":{ "key":[ "UNIX System V" ], "property":[ "subclassof" ], "to_name":[ "UNIX 操作系统" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "是 UNIX 操作系统的一个分支。" ] }, "DOS":{ "key":[ "DOS" ], "property":[ "type" ], "to_name":[ "MS-DOS" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "DOS (Disk Operating System)：磁盘操作系统（缩写为DOS）是可以使用磁盘存储设备（例如软盘，硬盘驱动器或光盘）的计算机操作系统。" ] }, "操作系统":{ "key":[ "操作系统" ], "property":[ "type" ], "to_name":[ "UNIX 操作系统" ], "重要程度":[ 4 ], "所属章节":[ 1 ], "知识点描述":[ "操作系统（Operating System，OS）：是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。" ] }, "Gnome":{ "key":[ "Gnome" ], "property":[ "subclassof" ], "to_name":[ "Linux" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ "GNOME 是一个完全由自由软件组成的桌面环境。它的目标操作系统是Linux，但是大部分的 BSD 系统亦支持 GNOME。" ] }, "USB":{ "key":[ "USB" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ "USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视（机顶盒）、游戏机等其它相关领域。" ] }, "BIOS":{ "key":[ "BIOS" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 1 ], "所属章节":[ 6 ], "知识点描述":[ " BIOS(Basic Input Output System)：是在通电引导阶段运行硬件初始化，以及为操作系统提供运行时服务的固件。它是开机时运行的第一个软件。" ] }, "DMI":{ "key":[ "DMI" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "直接媒体接口，是英特尔专用的总线，用于电脑主板上南桥芯片和北桥芯片之间的连接。" ] }, "PCIe":{ "key":[ "PCIe" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "官方简称PCIe，是计算机总线的一个重要分支，它沿用现有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准。" ] }, "GDI":{ "key":[ "GDI" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "图形接口，是微软视窗系统提供的应用程序接口，也是其用来表征图形对象、将图形对象传送给诸如显示器、打印机之类输出设备的核心组件。" ] }, "GUI":{ "key":[ "GUI" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 4 ], "所属章节":[ 1 ], "知识点描述":[ "GUI (Graphical User Interface)：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互。" ] }, "shell":{ "key":[ "shell" ], "property":[ "subclassof" ], "to_name":[ "驱动程序" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ "它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。在过去，它是类似 Unix 的系统上唯一可用的用户界面。如今，除了命令行界面（CLI）外，我们还具有图形用户界面（GUI）。" ] }, "驱动程序":{ "key":[ "驱动程序" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线或其它沟通子系统与硬件形成连接的机制，这样使得硬件设备上的数据交换成为可能。" ] }, "SSF":{ "key":[ "SSF" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "最短路径优先算法，这是对先进先出算法的改进，这种算法因为减少了总的磁臂运动，从而缩短了平均响应时间。" ] }, "沙盒":{ "key":[ "沙盒" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 2 ], "所属章节":[ 10 ], "知识点描述":[ "沙盒是一种软件管理策略，可将应用程序与关键系统资源和其他程序隔离。它提供了一层额外的安全保护，可防止恶意软件或有害应用程序对你的系统造成负面影响。" ] }, "解释器":{ "key":[ "解释器" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 2 ], "所属章节":[ 10 ], "知识点描述":[ "解释器是一种程序，能够把编程语言一行一行解释运行。每次运行程序时都要先转成另一种语言再运行，因此解释器的程序运行速度比较缓慢。它不会一次把整个程序翻译出来，而是每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。" ] }, "输入输出内存管理单元":{ "key":[ "输入输出内存管理单元" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "在计算机中，输入输出内存管理单元（IOMMU）是将直接内存访问（DMA）I / O 总线连接到主存的内存管理单元（MMU）。" ] }, "平台即服务":{ "key":[ "平台即服务" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "平台即服务（PaaS）或应用程序平台即服务（aPaaS）或基于平台的服务是云计算服务的一种，它提供了一个平台，使客户可以开发，运行和管理应用程序，而无需构建和维护该应用程序。" ] }, "软件即服务":{ "key":[ "软件即服务" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 4 ], "所属章节":[ 10 ], "知识点描述":[ "它是一个提供特定软件服务访问的平台，是一种软件许可和交付模型，在该模型中，软件是基于订阅许可的，并且是集中托管的。" ] }, "Windows NT":{ "key":[ "Windows NT" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "是美国微软公司 1993 年推出的纯 32 位操作系统核心。" ] }, "FreeBSD":{ "key":[ "FreeBSD" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ "FreeBSD 是一个类 UNIX 的操作系统，也是 FreeBSD 项目的发展成果。" ] }, "数字版权管理（DRM）":{ "key":[ "数字版权管理（DRM）" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ "他是工具或技术保护措施（TPM）是一组访问控制技术，用于限制对专有硬件和受版权保护的作品的使用。" ] }, "Service Pack(SP)":{ "key":[ "Service Pack(SP)" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ "是程序的更新、修复和（或）增强的集合，以一个独立的安装包的形式发布。许多公司，如微软或Autodesk，通常在为某一程序而做的修补程序达到一定数量时，就发布一个Service Pack。" ] }, "复用":{ "key":[ "复用" ], "property":[ "subclassof" ], "to_name":[ "基础设施即服务" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "也称为共享，在操作系统中主要指示了时间和空间的管理。对资源进行复用时，不同的程序或用户轮流使用它。他们中的第一个开始使用资源，然后再使用另一个，依此类推。" ] }, "数据库知识":{ "key":[ "数据库知识" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。" ] }, "关系数据库":{ "key":[ "关系数据库" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "关系数据库，是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。" ] }, "关系代数":{ "key":[ "关系代数" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "关系代数是一种抽象的查询语言,它用对关系的运算来表达查询。" ] }, "关系数据库概述":{ "key":[ "关系数据库概述" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "（1）关系数据库：在一个给定的应用领域中，所有实体及实体之间联系的集合构成一个关系数据库。（2）关系数据库的型与值：关系数据库的型称为关系数据库模式，是对关系数据库的描述，若干域的定义，在这些域上定义的若干关系模式；关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常简称为关系数据库。" ] }, "关系数据库管理系统":{ "key":[ "关系数据库管理系统" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "关系数据库管理系统（Relational Database Management System：RDBMS）是指包括相互联系的逻辑组织和存取这些数据的一套程序 (数据库管理系统软件)。关系数据库管理系统就是管理关系数据库，并将数据逻辑组织的系统。常用的关系数据库管理系统产品是Oracle、IBM的DB2和微软的SQL Server。" ] }, "关系的完整性":{ "key":[ "关系的完整性" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "关系完整性即指关系的正确性、相容性和有效性。它是给定的关系模型中数据及其联系的所有制约和依存规则，用以限定数据库状态及状态变化，从而保证数据的正确、相容和有效。关系模型的完整性有三类: 实体完整性、参照完整性和用户定义的完整性。其中，实体完整性和参照完整性是关系模型必须满足的完整性约束条件。" ] }, "关系数据结构":{ "key":[ "关系数据结构" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "在关系型数据结构中，数据是用二维表格的形式来组织的，但与简单表格中的结构有本质的区别。这里的数据具有更严密的定义，如数据类型一致、数据不可再分割、两行数据不能相同等。关系数据结构具有简单、灵活、存储效率高等特性，所以在结构化数据组织过程中得到了广泛的应用。" ] }, "关系演算":{ "key":[ "关系演算" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "关系演算是以数理逻辑中的谓词演算为基础的。以谓词演算为基础的查询语言称为关系演算语言。用谓词演算作为数据库查询语言的思想最早见于Kuhns的论文。把谓词演算用于关系数据库语(即关系演算的概念)是出E.F.Codd提出来的。" ] }, "关系数据库标准语言SQL":{ "key":[ "关系数据库标准语言SQL" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "SQL（Structured Query Language），即结构化查询语言。SQL集数据查询（Data Query）、数据操纵（Data Manipulation）、数据定义（Data Definition）和数据控制（Data Control）功能于一体。特点：综合统一；高度非过程化；面向集合的操作方式；以同一种语法结构提供两种使用方法(交互式，嵌入式)；语言简洁，易学易用。" ] }, "数据库基本表的操作":{ "key":[ "数据库基本表的操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据库基本表的操作包括定义、修改、删除基本表等操作。" ] }, "索引操作":{ "key":[ "索引操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。但是查询速度的提高是以插入，更新，删除的速度为代价的，所以索引的作用在于提高一个海量数据的检索速度。常见索引分为：主键索引(primary key)、唯一索引(unique)、普通索引(index)、全文索引(fulltext)。" ] }, "查询操作":{ "key":[ "查询操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据库的作用主要是用于对数据进行存储、更新、删除、查询操作，即“增、删、改、查”，最重要的是查询。查询操作分为单表查询、连接查询、嵌套查询、集合查询。" ] }, "数据更新":{ "key":[ "数据更新" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据更新（data revision）是以新数据项或记录、替换数据文件或数据库中与之相对应的旧数据项或记录的过程。通过删除一修改一再插入的操作来实现。" ] }, "视图操作":{ "key":[ "视图操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "视图在本质上是一种虚拟表，其内容与真是表相似，包含一系列带有名称的列和行数据。视图的实际功能是封装了复杂的查询语句。视图并不在数据库中以存储数据值的形式存在。行和列数据来自定义视图的查询所引用的基本表，并且在具体引用视图时动态生成。" ] }, "数据控制":{ "key":[ "数据控制" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "数据库管理系统通过以下三步来实现数据控制：授权定义、存权处理、查权操作。" ] }, "授权定义":{ "key":[ "授权定义" ], "property":[ "subclassof" ], "to_name":[ "数据控制" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "具有授权资格的用户，如数据库管理员（Database Administrators，DBA）或建表户（Database Owner，DBO），通过数据控制语言（Data Control Language，DCL），将授权决定告知数据库管理系统。" ] }, "存权处理":{ "key":[ "存权处理" ], "property":[ "subclassof" ], "to_name":[ "数据控制" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "数据库管理系统把授权的结果编译后存入数据字典中。数据字典是由系统自动生成、维护的一组表，记录着用户标识、基本表、视图和各表的列描述以及系统的授权情况。" ] }, "查权操作":{ "key":[ "查权操作" ], "property":[ "subclassof" ], "to_name":[ "数据控制" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "当用户提出操作请求时，系统首先要在数据字典中查找用户的数据操作权限，当用户拥有该操作权时才能执行其操作，否则系统将拒绝其操作。" ] }, "嵌入式SQL":{ "key":[ "嵌入式SQL" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "嵌入式SQL(英文 Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。" ] }, "关系数据库设计理论":{ "key":[ "关系数据库设计理论" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "关系数据库设计理论主要包括三个方面的内容:函数依赖、范式(Normal Form)和模式设计。其中函数依赖起着核心作用,是模式分解和模式设计的基础,范式是模式分解的标." ] }, "关系模式的规范化":{ "key":[ "关系模式的规范化" ], "property":[ "subclassof" ], "to_name":[ "关系数据库设计理论" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "关系模式的规范化实际上就是按照不同级别范式的要求条件对模式进行逐渐分解的过程。" ] }, "关系模式的分解":{ "key":[ "关系模式的分解" ], "property":[ "subclassof" ], "to_name":[ "关系模式的规范化" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "把一个关系模式分解成若干个关系模式的过程，称为关系模式的分解。关系模式分解必须遵守两个准则(1)无损联接性：信息不失真（不增减信息）。(2)函数依赖保持性：不破坏属性间存在的依赖关系。" ] }, "关系模式规范化的步骤":{ "key":[ "关系模式规范化的步骤" ], "property":[ "subclassof" ], "to_name":[ "关系模式的规范化" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "1,找出码;2,找出所有的非平凡依赖;3,找出违反范式的非平凡依赖;4,依据非平凡依赖就可以分解了。" ] }, "数据依赖":{ "key":[ "数据依赖" ], "property":[ "subclassof" ], "to_name":[ "关系数据库设计理论" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "数据依赖是指一种状态，当程序结构导致数据引用之前处理过的数据时的状态。在编译学中，数据依赖是数据分析的一部分。" ] }, "关系模式中的数据依赖":{ "key":[ "关系模式中的数据依赖" ], "property":[ "subclassof" ], "to_name":[ "数据依赖" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "数据依赖是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。现在人们已经提出了许多种类型的数据依赖，其是最重要的是函数依赖和多值依赖。" ] }, "数据依赖对关系模式的影响":{ "key":[ "数据依赖对关系模式的影响" ], "property":[ "subclassof" ], "to_name":[ "数据依赖" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "规范化理论是用来改造关系模式的，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。" ] }, "范式":{ "key":[ "范式" ], "property":[ "subclassof" ], "to_name":[ "关系数据库设计理论" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "范式就是关系数据库中满足不同规范化程度的关系模式的类。" ] }, "数据库设计":{ "key":[ "数据库设计" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库设计(Database Design)是指根据用户的需求，在某一具体的数据库管理系统上，设计数据库的结构和建立数据库的过程。数据库系统需要操作系统的支持。" ] }, "数据库实施":{ "key":[ "数据库实施" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库的实施主要是根据逻辑结构设计和物理结构设计的结果,在计算机系统上建立实际的数据库结构、导入数据并进行程序的调试。" ] }, "数据库物理设计":{ "key":[ "数据库物理设计" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库物理设计就是设计数据库的物理结构，根据数据库的逻辑结构来选定RDBMS（如Oracle、Sybase等），并设计和实施数据库的存储结构、存取方式等。" ] }, "数据库运行与维护":{ "key":[ "数据库运行与维护" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库系统投入正式运行，意味着数据库的设计与开发阶段的基本结束，运行与维护阶段的开始。数据库的运行和维护是个长期的工作，是数据库设计工作的延续和提高。在数据库运行阶段，完成对数据库的日常维护，工作人员需要掌握DBMS的存储、控制和数据恢复等基本操作，而且要经常性地涉及物理数据库、甚至逻辑数据库的再设计，因此数据库的维护工作仍然需要具有丰富经验的专业技术人员(主要是数据库管理员)来完成。" ] }, "数据库设计的步骤":{ "key":[ "数据库设计的步骤" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库设计通常分为6个阶段：（1）需求分析：分析用户的需求，包括数据、功能和性能需求；（2）概念结构设计：主要采用E-R模型进行设计，包括画E-R图；（3）逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；（4）数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；（5）数据库的实施：包括编程、测试和试运行；（6）数据库运行与维护：系统的运行与数据库的日常维护。" ] }, "概念结构设计":{ "key":[ "概念结构设计" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "概念结构设计的任务是在需求分析阶段产生的需求说明书的基础上，按照特定的方法把它们抽象为一个不依赖于任何具体机器的数据模型，即概念模型。概念模型使设计者的注意力能够从复杂的实现细节中解脱出来，而只集中在最重要的信息的组织结构和处理模式上。" ] }, "逻辑结构设计":{ "key":[ "逻辑结构设计" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "逻辑结构设计是将概念结构设计阶段完成的概念模型，转换成能被选定的数据库管理系统(DBMS)支持的数据模型。这里主要将E-R模型转换为关系模型。需要具体说明把原始数据进行分解、合并后重新组织起来的数据库全局逻辑结构，包括所确定的关键字和属性、重新确定的记录结构和文件结构、所建立的各个文件之间的相互关系，形成本数据库的数据库管理员视图。" ] }, "需求分析":{ "key":[ "需求分析" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据需求分析是从对数据进行组织与存储的角度,从用户视图出发,分析与辨别应用领域所管理的各类数据项(Data Items)和数据结构,形成数据字典的主要内容。" ] }, "数据抽象":{ "key":[ "数据抽象" ], "property":[ "subclassof" ], "to_name":[ "概念结构设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据抽象结构是对现实世界的一种抽象从实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节把这些特性用各种概念精确地加以描述这些概念组成了某种模型。包括分类、聚集和概括三种常用抽象。" ] }, "概念结构设计的方法与步骤":{ "key":[ "概念结构设计的方法与步骤" ], "property":[ "subclassof" ], "to_name":[ "概念结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "概念结构设计主要有四种策略：自顶向下，自底向上，由里向外（逐步扩张）和混合策略。方法是先画出组织的局部E-R图，然后将其合并，在此基础进行优化和美化。" ] }, "视图的集成":{ "key":[ "视图的集成" ], "property":[ "subclassof" ], "to_name":[ "概念结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "把基于不同用户视角的局部ER图集成为一个统一的、没有冗余的全局ER图。局部ER图（概念数据模型）的集成一般有如下四个步骤：（1）集成策略选择（2）比较实体关系图（3）统一实体关系元素（4）合并、重构实体关系图" ] }, "E-R图向数据模型的转换":{ "key":[ "E-R图向数据模型的转换" ], "property":[ "subclassof" ], "to_name":[ "逻辑结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "一般的转换原则为：一个实体型转换为一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码。" ] }, "数据模型的优化":{ "key":[ "数据模型的优化" ], "property":[ "subclassof" ], "to_name":[ "逻辑结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "通常以规范化理论为指导，优化方法为确定数据依赖，对各个关系模式之间的数据依赖进行极小化处理。" ] }, "设计用户子模式":{ "key":[ "设计用户子模式" ], "property":[ "subclassof" ], "to_name":[ "逻辑结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "根据局部应用需求设计用户子模式。目的是保证系统安全性，简化用户对系统的使用，DBMS中一般采用视图机制。" ] }, "数据字典":{ "key":[ "数据字典" ], "property":[ "subclassof" ], "to_name":[ "需求分析" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它通常包括数据项、数据结构、数据流、数据存储和处理过程几部分。" ] }, "需求分析的任务":{ "key":[ "需求分析的任务" ], "property":[ "subclassof" ], "to_name":[ "需求分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "需求分析的任务是通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）的工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。新系统必须充分考虑今后可能的扩充和改变，不能仅仅按当前应用需求来设计数据库。" ] }, "需求分析的方法":{ "key":[ "需求分析的方法" ], "property":[ "subclassof" ], "to_name":[ "需求分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "从系统分析出发，可将需求分析方法大致分为功能分解方法、结构化分析方法、信息建模法和面向对象的分析方法。常用结构化分析（SA）方法：从最上层系统组织机构入手，采用自顶向下、逐层分解的方式分析系统。" ] }, "专门的关系运算":{ "key":[ "专门的关系运算" ], "property":[ "type" ], "to_name":[ "关系代数" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "专门的运算关系包括选择、投影、连接、除运算四种。" ] }, "选择":{ "key":[ "选择" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：在关系R中选出满足指定条件F的元组(行操作)。表达式：σF(R) = {t|t∈R∧F(t)='真'}" ] }, "投影":{ "key":[ "投影" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：从关系R中选出若干属性A组成新关系(列操作)。表达式：πA(R) = {t[A]|t∈R}" ] }, "连接":{ "key":[ "连接" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：从两个关系R和S的笛卡尔积中选取属性间满足指定条件AθB的元组。表达式：R∞S(AθB) = {t(r)t(s)|t(r)∈R∧t(s)∈S∧t(r)[A]θt(s)[B]}拓展关系：连接分两种：等值连接与自然连接①等值连接：指定条件AθB的θ为'='时②自然连接：在等值连接的基础上去除重复的属性" ] }, "除运算":{ "key":[ "除运算" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：设关系R除以关系S的结果为关系T,则T包含所有在R但不在S中的属性及值,且T的元组与S的元组的所有组合都在R中。表达式：R÷S = {t(r)[X]|t(r)∈R∧π(Y)(S)属于Y(x)},其中Y(x)为x在R中的象集,x=t(r)[X]" ] }, "传统的集合运算":{ "key":[ "传统的集合运算" ], "property":[ "type" ], "to_name":[ "关系代数" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "传统的集合运算是二目运算，它包括并、差、交、笛卡尔积4种运算。" ] }, "并":{ "key":[ "并" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域，则：关系R与关系S的并记为：R∪S={t|t∈R?t∈S}，其结果仍为n目关系，由属性R或属性S的元组组成。" ] }, "差":{ "key":[ "差" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域，则：关系R与关系S的差记为：R-S={t|t∈R?t?S}，其结果关系仍为n目关系，由属于R而不属于S的所有元组组成。" ] }, "交":{ "key":[ "交" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域，则：关系R与关系S的交记为：R∩S={t∈R?t∈S}其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交运算可以用差运算来表示，即R∩S= R-(R-S)。" ] }, "笛卡尔积":{ "key":[ "笛卡尔积" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域。这里的笛卡尔积严格地讲是广义笛卡尔积(Extended Cartesian Product)。在不会出现混淆的情况下广义笛卡尔积也称为笛卡尔积。两个分别为n目和m目的关系R和S的笛卡尔积是一个n+m列的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。若R有k1个元组，S有K2个元组，则关系R和关系S的迪卡尔积有K1  K2个元组。记作：R×S={(t_r t_s ) ?|t_r∈R?t_s∈S}。" ] }, "元组关系演算语言":{ "key":[ "元组关系演算语言" ], "property":[ "type" ], "to_name":[ "关系演算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "元组关系演算以元组变量作为谓词变元的基本对象。典型的元组关系演算语言是E.F.Codd提出的ALPHA语言，但这一语言并没有实际实现。现在关系库管理系统INGRES所用的QUEL语言是参会照ALPHA语言研制的，与ALPHA十分相似。ALPHA语言语句的基本格式是:操作语句 工作空间名(表达式):操作条件" ] }, "域关系演算语言":{ "key":[ "域关系演算语言" ], "property":[ "type" ], "to_name":[ "关系演算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "域关系演算是另一种形式的关系演算。域关系演算以元组变量的分量(即域变量)作为谓词变元的基本对象。QBE是一个很特色的域关系演算语言，穹由M.MZloof于1975年提出，关于1978年在IBM370上得以实现。QBE是Query By Example(即通过例子进行查询)的简称，它是一种关系语言，同时也指使用此语言的关系数据库时系统。" ] }, "定义基本表":{ "key":[ "定义基本表" ], "property":[ "type" ], "to_name":[ "数据库基本表的操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "SQL语言用CREATE TABLE语句定义基本表。" ] }, "修改基本表":{ "key":[ "修改基本表" ], "property":[ "type" ], "to_name":[ "数据库基本表的操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "SQL语言用ALTER TABLE语句修改基本表" ] }, "删除基本表":{ "key":[ "删除基本表" ], "property":[ "type" ], "to_name":[ "数据库基本表的操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "当某个基本表不再需要时，可以使用SQL语句DROP TABLE进行删除。" ] }, "查询索引":{ "key":[ "查询索引" ], "property":[ "type" ], "to_name":[ "索引操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "使用SHOW INDEX 命令来列出表中的相关的索引信息。实例：show index 索引名 from 表名" ] }, "创建索引":{ "key":[ "创建索引" ], "property":[ "type" ], "to_name":[ "索引操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "索引被创建于已有的表中，它可使对行的定位更快速更有效。使用CREATE 语句创建索引。实例：CREATE INDEX新建的索引名 ON 表名(表中的列)" ] }, "删除索引":{ "key":[ "删除索引" ], "property":[ "type" ], "to_name":[ "索引操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "当某个索引不再需要时，可以使用SQL语句DROP INDEX进行删除。实例：Drop index 索引名 on 表名" ] }, "单表查询":{ "key":[ "单表查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "查询仅涉及一个表，是一种最简单的查询操作。（1）选择表中的若干列（2）选择表中的若干元组（3）对查询结果排序（4）使用集函数（5）对查询结果分组" ] }, "连接查询":{ "key":[ "连接查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "内连接的连接查询结果集中仅包含满足条件的行，内连接是SQL Server缺省的连接方式，可以把INNERJOIN简写成JOIN，根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种；交叉连接的连接查询结果集中包含两个表中所有行的组合；外连接的连接查询结果集中既包含那些满足条件的行，还包含其中某个表的全部行，有3种形式的外连接：左外连接、右外连接、全外连接。" ] }, "嵌套查询":{ "key":[ "嵌套查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "嵌套查询指包含一个或多个子查询或者子查询的另一个术语的SELECT语句。其中外层查询称为主查询，内层查询称为子查询。" ] }, "集合查询":{ "key":[ "集合查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "在数学中可以对集合做交并差运算，在 SQL 中同样可以对查询结果集做交并差操作。这三种 SQL 集合查询对应的操作符关键字分别是 INTERSECT、UNION/UNION ALL、MINUS。" ] }, "插入数据":{ "key":[ "插入数据" ], "property":[ "type" ], "to_name":[ "数据更新" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "SQL数据插入一般有两种格式，一种是单行数据插入，一种是子查询结果插入。关键词是INSERT。" ] }, "修改数据":{ "key":[ "修改数据" ], "property":[ "type" ], "to_name":[ "数据更新" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据修改的关键词是UPDATE，一般格式为：UPDATE 表名 SET 更新内容 WHERE 更新条件,其中，SET子句中的更新内容是以“属性名=表达式”的形式出现的。" ] }, "删除数据":{ "key":[ "删除数据" ], "property":[ "type" ], "to_name":[ "数据更新" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据删除的关键词是DELETE，一般格式为：DELETE FROM 表名 WHERE 删除条件,其中，DELETE子句删除表中的数据，并不影响表的结构。" ] }, "定义视图":{ "key":[ "定义视图" ], "property":[ "type" ], "to_name":[ "视图操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "语法形式：create view view_name as 查询语句;先创建t_product表，然后插入4条数据记录，最后制作视图。" ] }, "查询视图":{ "key":[ "查询视图" ], "property":[ "type" ], "to_name":[ "视图操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "语法形式：show create view view_name;desc view_name;select * from view_name;" ] }, "更新视图":{ "key":[ "更新视图" ], "property":[ "type" ], "to_name":[ "视图操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "语法形式：create or replace view view_name as 查询语句;" ] }, "BC范式":{ "key":[ "BC范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。" ] }, "第一范式":{ "key":[ "第一范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "第一范式是规范化约束范式。" ] }, "第三范式":{ "key":[ "第三范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。" ] }, "第二范式":{ "key":[ "第二范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "第二范式(Second Normal Form,2nd NF)是指每个表必须有主关键字(Primary key),其他数据元素与主关键字一一对应。若关系模式R∈1NF（即R符合第一范式），并且每一个非主属性都完全依赖于R的主码，则R∈2NF（即R符合第二范式）。" ] }, "文件传输协议":{ "key":[ "文件传输协议" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。" ] }, "万维网":{ "key":[ "万维网" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "万维网WWW是World Wide Web的简称，也称为Web、3W等。WWW是基于客户机/服务器方式的信息发现技术和超文本技术的综合。" ] }, "网络应用模型":{ "key":[ "网络应用模型" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "包括客户服务器模型和P2P模型" ] }, "电子邮件":{ "key":[ "电子邮件" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "电子邮件是—种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。" ] }, "域名系统":{ "key":[ "域名系统" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。" ] }, "SMTP":{ "key":[ "SMTP" ], "property":[ "type" ], "to_name":[ "电子邮件" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。" ] }, "POP3":{ "key":[ "POP3" ], "property":[ "type" ], "to_name":[ "电子邮件" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。" ] }, "C/S模型":{ "key":[ "C/S模型" ], "property":[ "type" ], "to_name":[ "网络应用模型" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "服务器-客户机，即Client-Server(C/S)结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。" ] }, "P2P模型":{ "key":[ "P2P模型" ], "property":[ "type" ], "to_name":[ "网络应用模型" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "点对点技术又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上" ] }, "超文本传输协议":{ "key":[ "超文本传输协议" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。" ] }, "超文本标记语言":{ "key":[ "超文本标记语言" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "HTML称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。" ] }, "统一资源定位符":{ "key":[ "统一资源定位符" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "统一资源定位系统（uniform resource locator;URL）是因特网的万维网服务程序上用于指定信息位置的表示方法。" ] }, "IPV4":{ "key":[ "IPV4" ], "property":[ "type" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网际协议版本4（英语：InternetProtocolversion4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANAIPv4位址完全用尽时，IPv6仍处在部署的初期。" ] }, "IPV6":{ "key":[ "IPV6" ], "property":[ "type" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IPv6是英文“Internet Protocol Version 6”（互联网协议第6版）的缩写，是互联网工程任务组（IETF）设计的用于替代IPv4的下一代IP协议" ] }, "路由协议":{ "key":[ "路由协议" ], "property":[ "前驱关系" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "路由协议（英语：Routing protocol）是一种指定数据包转送方式的网上协议。Internet网络的主要节点设备是路由器，路由器通过路由表来转发接收到的数据。" ] }, "无分类编址CIDR":{ "key":[ "无分类编址CIDR" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ "无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。" ] }, "子网划分":{ "key":[ "子网划分" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "子网划分定义：Internet组织机构定义了五种IP地址，有A、B、C三类地址。" ] }, "子网掩码":{ "key":[ "子网掩码" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。" ] }, "IPV4地址与NAT":{ "key":[ "IPV4地址与NAT" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "协议":{ "key":[ "协议" ], "property":[ "前驱关系" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "动态主机配置协议DHCP":{ "key":[ "动态主机配置协议DHCP" ], "property":[ "type" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。" ] }, "地址解析协议ARP":{ "key":[ "地址解析协议ARP" ], "property":[ "type" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；" ] }, "IPV4地址":{ "key":[ "IPV4地址" ], "property":[ "subclassof" ], "to_name":[ "IPV4地址与NAT" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "无论你是使用智能手机上网还是使用PC机上网，你的手机或PC机都会被分配一个IP地址，手机或PC机使用这个IP地址与互联网上的其它网络通信并进行信息交换。" ] }, "网络地址转换":{ "key":[ "网络地址转换" ], "property":[ "subclassof" ], "to_name":[ "IPV4地址与NAT" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。" ] }, "自治系统":{ "key":[ "自治系统" ], "property":[ "前驱关系" ], "to_name":[ "路由协议" ], "重要程度":[ 1 ], "所属章节":[ "4" ], "知识点描述":[ "自治系统：autonomous system。在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。" ] }, "内部网关协议IGP":{ "key":[ "内部网关协议IGP" ], "property":[ "type" ], "to_name":[ "路由协议" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IGP（内部网关协议）是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。" ] }, "外部网关协议EGP":{ "key":[ "外部网关协议EGP" ], "property":[ "type" ], "to_name":[ "路由协议" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "EGP是一种简单的（网络）可达性协议，其与现代的距离-矢量协议和路径-矢量协议不同，它仅限适用于树状拓扑的网络。" ] }, "BGP协议":{ "key":[ "BGP协议" ], "property":[ "type" ], "to_name":[ "外部网关协议EGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议" ] }, "RIP协议":{ "key":[ "RIP协议" ], "property":[ "type" ], "to_name":[ "内部网关协议IGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "RIP(Routing Information Protocol,路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。" ] }, "OSPF协议":{ "key":[ "OSPF协议" ], "property":[ "type" ], "to_name":[ "内部网关协议IGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。" ] }, "网际协议IP":{ "key":[ "网际协议IP" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IP只为主机提供一种无连接、不可靠的、尽力而为的数据报传输服务。" ] }, "两种服务":{ "key":[ "两种服务" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "功能":{ "key":[ "功能" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "虚电路服务":{ "key":[ "虚电路服务" ], "property":[ "type" ], "to_name":[ "两种服务" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "虚电路服务是指是一种面向连接的，使所有分组顺序到达目的端的可 靠性数据传输服务。" ] }, "数据报服务":{ "key":[ "数据报服务" ], "property":[ "type" ], "to_name":[ "两种服务" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "数据报服务是由数据报交换网来提供。端系统的网络层同网络节点中的网络层之间，一致地按照数据报操作方式交换数据。" ] }, "异构网络互联":{ "key":[ "异构网络互联" ], "property":[ "subclassof" ], "to_name":[ "功能" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ "异构网络(Heterogeneous Network）是一种类型的网络，其是由不同制造商生产的计算机，网络设备和系统组成的，大部分情况下运行在不同的协议上支持不同的功能或应用。" ] }, "路由与转发":{ "key":[ "路由与转发" ], "property":[ "subclassof" ], "to_name":[ "功能" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "拥塞控制":{ "key":[ "拥塞控制" ], "property":[ "type" ], "to_name":[ "TCP功能" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。" ] }, "可靠传输机制":{ "key":[ "可靠传输机制" ], "property":[ "type" ], "to_name":[ "TCP功能" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "流量控制":{ "key":[ "流量控制" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "网络流量控制（Network traffic control）是利用软件或硬件方式来实现对网络数据流量进行控制的一种措施。" ] }, "TCP功能":{ "key":[ "TCP功能" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "TCP连接管理":{ "key":[ "TCP连接管理" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "TCP报文段":{ "key":[ "TCP报文段" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ "报文段 [1]  .是指TCP/IP协议网络传输过程中，起着路由导航，查询各个网络路由网段,IP地址，交换协议等IP数据包。报文段充当整个TCP/IP协议数据包的导航路由功能。" ] }, "传输层":{ "key":[ "传输层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "传输层是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务。" ] }, "UDP校验":{ "key":[ "UDP校验" ], "property":[ "前驱关系" ], "to_name":[ "UDP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "网络层":{ "key":[ "网络层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网络层位于物联网三层结构中的第二层，其功能为“传送”，即通过通信网络进行信息传输。" ] }, "应用层":{ "key":[ "应用层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "应用层是开放系统的最高层,是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时,完成一系列业务处理所需的服务." ] }, "数据链路层":{ "key":[ "数据链路层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间。数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。" ] }, "设备":{ "key":[ "设备" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "组帧":{ "key":[ "组帧" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "组帧bai就是把相关的信息资料组合在一起成为可以在网络du上传输zhi的数据" ] }, "介质访问":{ "key":[ "介质访问" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "介质访问控制(medium access control)简称MAC。 是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。" ] }, "可靠传输":{ "key":[ "可靠传输" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "传输技术 指充分利用不同信道的传输能力构成一个完整的传输系统，使信息得以可靠传输的技术。传输系统是通信系统的重要组成部分，传输技术主要依赖于具体信道的传输特性。" ] }, "差错控制":{ "key":[ "差错控制" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "差错控制（error control）是在数字通信中利用编码方法对传输中产生的差错进行控制，以提高数字消息传输的准确性。" ] }, "随机访问":{ "key":[ "随机访问" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "轮询访问":{ "key":[ "轮询访问" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "轮询访问技术是一种受控访问技术。在由多个结点共享公用信道的线路中，主机依照一定的顺序探询各结点有无传送信息的要求，被探询的结点如有传送要求就占用公用信道，将信息发送给主机否则，主机继续探询下一结点。" ] }, "信道划分":{ "key":[ "信道划分" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "码分复用":{ "key":[ "码分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "码分复用是用一组包含互相正交的码字的码组携带多路信号。采用同一波长的扩频序列，频谱资源利用率高，与WDM结合，可以大大增加系统容量。" ] }, "频分复用":{ "key":[ "频分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "频分复用(FDM，Frequency Division Multiplexing)就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输1路信号。" ] }, "时分复用":{ "key":[ "时分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "时分复用TDM是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的目的。" ] }, "波分复用":{ "key":[ "波分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "波分复用WDM(Wavelength Division Multiplexing)是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；" ] }, "CSMA/CD协议":{ "key":[ "CSMA/CD协议" ], "property":[ "subclassof" ], "to_name":[ "随机访问" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "CSMA/CD即载波侦听多路访问/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点。" ] }, "集线器":{ "key":[ "集线器" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "集线器的英文称为“Hub”。“Hub”是“中心”的意思，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。" ] }, "交换机":{ "key":[ "交换机" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。" ] }, "网桥":{ "key":[ "网桥" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。" ] }, "物理层":{ "key":[ "物理层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ "物理层（或称物理层，Physical Layer）是计算机网络OSI模型中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。" ] }, "传输介质":{ "key":[ "传输介质" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ "网络传输介质是指在网络中传输信息的载体，常用的传输介质分为有线传输介质和无线传输介质两大类。" ] }, "通信基础":{ "key":[ "通信基础" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "体系结构":{ "key":[ "体系结构" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ "2，3，4，5，6" ], "知识点描述":[ ] }, "具体应用":{ "key":[ "具体应用" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ ] }, "基本概念":{ "key":[ "基本概念" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "网络安全":{ "key":[ "网络安全" ], "property":[ "subclassof" ], "to_name":[ "具体应用" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "网络安全是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断" ] }, "互联网的组成":{ "key":[ "互联网的组成" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "核心部分":{ "key":[ "核心部分" ], "property":[ "type" ], "to_name":[ "互联网的组成" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "边缘部分":{ "key":[ "边缘部分" ], "property":[ "type" ], "to_name":[ "互联网的组成" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "计算机网络性能指标":{ "key":[ "计算机网络性能指标" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 3 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "速率":{ "key":[ "速率" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "吞吐量":{ "key":[ "吞吐量" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "吞吐量是指网络中主机（server和client）之间的实际数据传输速率，即单位时间内实际传输的数据量，常用的单位有Kbps,Mbps。" ] }, "往返时间RTT":{ "key":[ "往返时间RTT" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间。" ] }, "计算机网络类别":{ "key":[ "计算机网络类别" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "个人区域网":{ "key":[ "个人区域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "个人局域网（英语：Personal Area Network，缩写为PAN），指个人范围（随身携带或数米之内）的计算设备（如计算机、电话、PDA、数字相机等）组成的通信网络。" ] }, "城域网":{ "key":[ "城域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "城域网(Metropolitan Area Network)是在一个城市范围内所建立的计算机通信网，简称MAN。属宽带局域网。" ] }, "局域网":{ "key":[ "局域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛" ] }, "广域网":{ "key":[ "广域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "广域网（英语：Wide Area Network，缩写为 WAN），又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。" ] }, "带宽":{ "key":[ "带宽" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "带宽是指网络的最大数据传输速率，常用单位也是Kbps,Mbps。" ] }, "信道利用率":{ "key":[ "信道利用率" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "信道利用率是指发送时延除以发送时延加上往返传输时延" ] }, "传输方式":{ "key":[ "传输方式" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "定理":{ "key":[ "定理" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "信道":{ "key":[ "信道" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "指通信的通道，是信号传输的媒介" ] }, "调制与解码":{ "key":[ "调制与解码" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "调制就是用基带信号去控制载波信号的某个或几个参量的变化，将信息荷载在其上形成已调信号传输，而解调是调制的反过程，通过具体的方法从已调信号的参量变化中将恢复原始的基带信号。" ] }, "全双工":{ "key":[ "全双工" ], "property":[ "type" ], "to_name":[ "信道" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。" ] }, "半双工":{ "key":[ "半双工" ], "property":[ "type" ], "to_name":[ "信道" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。" ] }, "分组交换":{ "key":[ "分组交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。" ] }, "报文交换":{ "key":[ "报文交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "报文交换（英语：Message switching），又称存储转发交换，是数据交换的三种方式之一，报文整个地发送，一次一跳。" ] }, "电路交换":{ "key":[ "电路交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "电路交换（CS:circuit switching）是通信网中最早出现的一种交换方式，也是应用最普遍的一种交换方式，主要应用于电话通信网中，完成电话交换" ] }, "数据报":{ "key":[ "数据报" ], "property":[ "type" ], "to_name":[ "分组交换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "数据报是通过网络传输的数据的基本单元，包含一个报头（header）和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。" ] }, "虚电路":{ "key":[ "虚电路" ], "property":[ "type" ], "to_name":[ "分组交换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "虚电路是分组交换的两种传输方式中的一种。在通信和网络中，虚电路是由分组交换通信所提供的面向连接的通信服务。" ] }, "NFA的状态转换图":{ "key":[ "NFA的状态转换图" ], "property":[ "subclassof" ], "to_name":[ "不确定有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "若设NFA M含有n个状态和m个输入符号，则这个图含有n个状态结点，每个结点可射出若干箭弧与其它的状态结点相连接。对于w∈{ε}∪Σ，若δ(q0，a)={q1，q2，…，qk}(k≥0)，则从q0出发，分别到q1，q2，…，qk的k条弧，弧上均标记为a。整张图含有唯一的初态结点和若干终态结点。" ] }, "NFA识别字符串":{ "key":[ "NFA识别字符串" ], "property":[ "subclassof" ], "to_name":[ "不确定有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "对Σ*上的任何符号串，若存在一条从某一初态结点到某一终态结点的通路，且该通路上所有弧的标记符号依次连接成的字符串等于w，则称w可被NFA M所识别。若M的某些结点同时又是终态结点，则空字符串ε被M所识别。" ] }, "DFA和NFA的关系":{ "key":[ "DFA和NFA的关系" ], "property":[ "subclassof" ], "to_name":[ "不确定有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "1）DFA是NFA的特例，NFA是DFA概念的推广。 2）NFA能识别的语言都能被一个DFA识别。3）DFA相对NFA的识别程序更容易实现。" ] }, "DFA的状态转移矩阵":{ "key":[ "DFA的状态转移矩阵" ], "property":[ "subclassof" ], "to_name":[ "确定的有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "DFA可用一个二维矩阵表示，矩阵的行表示状态，列表示输入字符，矩阵元素表示δ(s，a)的值。" ] }, "DFA的状态转换图":{ "key":[ "DFA的状态转换图" ], "property":[ "subclassof" ], "to_name":[ "确定的有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ " 若设DFA M含有m个状态和n个输入字符，则这个图含有m个状态结点，每个结点至多有n条箭弧射出与其它的状态结点相连接，每个箭弧用Σ中的一个不同输入字符作为标记。整张图含有唯一的初态结点和若干终态结点。" ] }, "DFA识别字符串":{ "key":[ "DFA识别字符串" ], "property":[ "subclassof" ], "to_name":[ "确定的有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "对Σ上的任何符号串w∈Σ*，若存在一条从初态结点到某一终态结点的通路，且该通路上所有弧的标记符连接成的字符串等于w，则称w可被DFA M所识别。若M的初态结点同时又是终态结点，则空字符串ε被M所识别。" ] }, "δ的递归扩展定义":{ "key":[ "δ的递归扩展定义" ], "property":[ "subclassof" ], "to_name":[ "确定的有限自动机" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ " 对一个DFA M，其识别的语言L(M)={w|w∈Σ*，若存在Z∈F，使δ(s0，w)=Z}，其中：w=ua∈Σ*，则δ(s，ε)=s，δ(s，ua)= δ(δ(s，u)，a)。" ] }, "正规式的运算":{ "key":[ "正规式的运算" ], "property":[ "subclassof" ], "to_name":[ "正规式与正规集" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "1）种类：或”|”、连接”.”、闭包”*”。 2）优先级：闭包>连接>或 ；3）说明：仅由有限次使用这三种运算而得到的表达式才是Σ上的正规式。仅由这些正规式表示的单词集才是Σ上的正规式。" ] }, "正规式的等价":{ "key":[ "正规式的等价" ], "property":[ "subclassof" ], "to_name":[ "正规式与正规集" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "若两个正规式U和V描述的正规集相同，则称正规式U和V等价。" ] }, "正规式与正规集":{ "key":[ "正规式与正规集" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ ] }, "不确定有限自动机":{ "key":[ "不确定有限自动机" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ "定义：一个不确定有限自动机(NFA) M是一个五元组：M=(S，Σ，δ，S0，F)" ] }, "确定的有限自动机":{ "key":[ "确定的有限自动机" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 1 ], "所属章节":[ 3 ], "知识点描述":[ "定义：一个确定的有限自动机(DFA) M是一个五元组：M=(S，Σ，δ，s0，F)" ] }, "正规文法转换为正规式":{ "key":[ "正规文法转换为正规式" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ " 1）将正规文法中的每个非终结符表示成它的一个正规式方程，获得一个联立方程组。 2）若x=αx|β(或x=αx+β)，则解为x=α*β。3）若x=xα|β(或x=xα+β)，则解为x=βα*。" ] }, "NFA的确定化":{ "key":[ "NFA的确定化" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "对任给的NFA M。都能相应地构造一个DFA M‘，使得L(M’)=L(M)。" ] }, "NFA的化简思路":{ "key":[ "NFA的化简思路" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "DFA的每一个状态代表NFA状态集合的某个子集，构造的DFA使用它的状态去记录NFA读入输入符号之后可能到达的所有状态的集合。" ] }, "单词的种类":{ "key":[ "单词的种类" ], "property":[ "同义关系" ], "to_name":[ "词法分析器的任务" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "关键字、标识符、常数、运算符、界限符" ] }, "Follow集":{ "key":[ "Follow集" ], "property":[ "subclassof" ], "to_name":[ "LL(1)文法" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "设G[Z]=(VN，VT，P，Z)，A∈VN，非终结符号A的后继符号集合的定义为： Follow(A)={a|Z ?* …Aa…且a∈VT}  若Z ?* …A，则规定#∈First(A)。#为结束符。" ] }, "First集":{ "key":[ "First集" ], "property":[ "subclassof" ], "to_name":[ "LL(2)文法" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "设G[Z]=(VN，VT，P，Z)，α∈(VN∪VT)*，符号串α的首符号集合的定义为： First(α)={a|α ?* a…且a∈VT}  若α ?* ε，则规定ε∈First(α)。" ] }, "回溯的判断":{ "key":[ "回溯的判断" ], "property":[ "subclassof" ], "to_name":[ "LL(3)文法" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "对一个上下文无关文法G[Z]=(VN，VT，P，Z)，对某个产生式规则A→α1|α2|…αn，若存在a∈VT，使得a∈First(αi)∩First(αj)(1≤i,j≤n且i≠j)或a∈First(αi)∩Follow(A)(1≤i≤n，A ?* ε)或αi ?* ε且αj ?* ε(1≤i,j≤n且i≠j)，则对应于文法G的自顶向下分析需要回溯。" ] }, "回溯的消除":{ "key":[ "回溯的消除" ], "property":[ "subclassof" ], "to_name":[ "LL(4)文法" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ " 1）提取左因子。若有A→αβ1|αβ2|…|αβ1|γ，其中γ不是以α开头的候选式，则A的产生式规则可替换为A→αA‘|γ，A’→β1|β2|…|βn。A’是一个新的非终结符号。 2）消除左递归。" ] }, "出错情况":{ "key":[ "出错情况" ], "property":[ "subclassof" ], "to_name":[ "预测分析的出错处理" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ " 1）栈顶上的终结符号与下一个输入符号不匹配。 2）栈顶上是非终结符号A，下一个输入符号是a，但分析表M[A,a]为空。" ] }, "解决思路":{ "key":[ "解决思路" ], "property":[ "subclassof" ], "to_name":[ "预测分析的出错处理" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "跳过输入串中的一些符号，直到遇到“同步符号“为止。" ] }, "同步符号集的选择":{ "key":[ "同步符号集的选择" ], "property":[ "subclassof" ], "to_name":[ "预测分析的出错处理" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ " 1）把Follow(A)中的所有符号放入非终结符A的同步符号集。若跳读一些符号直到出现Follow(A)中的符号，把A从栈中弹出，这样就可能使分析继续下去。 2）对于非终结符A，只用Follow(A)作为它的同步符号集是不够的。" ] }, "预测分析的出错处理":{ "key":[ "预测分析的出错处理" ], "property":[ "同义关系" ], "to_name":[ "语法分析器" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "1.出错情况  2.解决思路 3.同步符号集的选择" ] }, "LL(1)文法":{ "key":[ "LL(1)文法" ], "property":[ "同义关系" ], "to_name":[ "语法分析器" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "定义:1）文法不含左递归。 2）对某个非终结符A，若其对应的产生式规则为A→α1|α2|…αn，则First(αi)∩First(αj)=?(1≤i,j≤n且i≠j)。  3）对文法中的每个非终结符A，若A ?* ε，则First(αi)∩Follow(A)=?(1≤i≤n)。" ] }, "递归下降分析器。":{ "key":[ "递归下降分析器。" ], "property":[ "同义关系" ], "to_name":[ "语法分析器" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "定义：由一组递归函数或过程组成，每个函数或过程对应文法的一个非终结符的程序，称为递归下降分析器。" ] }, "语法分析方法的种类":{ "key":[ "语法分析方法的种类" ], "property":[ "subclassof" ], "to_name":[ "语法分析器" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "自顶向下和自底向上。" ] }, "自顶向下的语法分析":{ "key":[ "自顶向下的语法分析" ], "property":[ "subclassof" ], "to_name":[ "语法分析器" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "定义：从顶部(树根)建立语法分析树，构造一个最左推导，面对当前输入的单词符号和当前被替换的非终结符，选择这个非终结符的某个产生式规则进行替换。" ] }, "L-属性定义":{ "key":[ "L-属性定义" ], "property":[ "同义关系" ], "to_name":[ "S-属性定义" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "若文法G的每一条产生式规则A→X1X2…Xn所配置的语义规则中的每一个属性或者都是综合属性，或者是Xk的一个继承属性，且该继承属性仅依赖于A的继承属性及Xk左部的X1，X2，…，Xk-1的任何属性，则称该属性文法为L-属性定义(L-属性文法)。" ] }, "S-属性定义":{ "key":[ "S-属性定义" ], "property":[ "同义关系" ], "to_name":[ "属性文法" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "若属性文法中所有的属性均为综合属性，则称为S-属性定义(S-属性文法)。" ] }, "栈中的继承属性":{ "key":[ "栈中的继承属性" ], "property":[ "同义关系" ], "to_name":[ "属性文法" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "1.复写规则：设Y.y是继承属性，X.s是综合属性，且有Y.y=X.s，则称Y.y=X.s为复写规则。2.基本思想：在引用继承属性时，引用其指向的综合属性。" ] }, "综合属性":{ "key":[ "综合属性" ], "property":[ "subclassof" ], "to_name":[ "属性文法" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "使用场景：一个结点的综合属性值由其子结点的属性值确定" ] }, "继承属性":{ "key":[ "继承属性" ], "property":[ "subclassof" ], "to_name":[ "属性文法" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "使用场景：一个结点的继承属性值由其父结点的属性值或兄弟结点的属性值来确定。用于表达上下文的依赖性。" ] }, "属性文法":{ "key":[ "属性文法" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "对文法中的每一个符号(终结符或非终结符)指派若干表达语义的值，这些值称为属性。在上下文无关文法中配置上语义规则，这样的文法称为属性文法。" ] }, "语法分析器":{ "key":[ "语法分析器" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "功能：以词法分析器生成的单词符号序列作为输入，在分析过程中验证这个单词符号序列是否是该程序设计语言的文法的一个句子。" ] }, "词法分析器的任务":{ "key":[ "词法分析器的任务" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "功能：输入源程序，输出单词符号。" ] }, "算符文法":{ "key":[ "算符文法" ], "property":[ "subclassof" ], "to_name":[ "算符优先关系" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "若文法G中不存在规则：A→UV…，其中A，U，V均为非终结符，则称该文法是算符文法。通常，算符文法也不包含A→ε。" ] }, "算符相邻":{ "key":[ "算符相邻" ], "property":[ "subclassof" ], "to_name":[ "算符优先关系" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "若有ab或aWb，其中a,b∈VT，W∈VN，则称运算符a与b相邻。" ] }, "算符优先级":{ "key":[ "算符优先级" ], "property":[ "subclassof" ], "to_name":[ "算符优先关系" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "设文法G是一个算符文法，对文法G中任何一对终结符a和b，定义： 1）a =· b：当且仅当文法G中存在规则A→…ab…或A→…aRb…，其中a,b∈VT，R∈VN。2）a ＜· b：当且仅当文法G中存在规则A→…aR…且R ?+ b…或R ?+ Qb…，其中a,b∈VT，Q,R∈VN。  3）a ·＞ b：当且仅当文法G中存在规则A→…Rb…且R ?+ …a或R ?+ …aQ，其中a,b∈VT，Q,R∈VN。" ] }, "算符优先文法":{ "key":[ "算符优先文法" ], "property":[ "subclassof" ], "to_name":[ "算符优先关系" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "若一个算符文法G中任何一对终结符号a与b之间最多存在=·、＜·、·＞中的一种，则称文法G是一个算符优先文法。" ] }, "优先函数的优点":{ "key":[ "优先函数的优点" ], "property":[ "subclassof" ], "to_name":[ "优先函数" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "优点：存储空间从n×n减小到2n。" ] }, "优先函数的缺点":{ "key":[ "优先函数的缺点" ], "property":[ "subclassof" ], "to_name":[ "优先函数" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "缺点：原本在优先关系表中不存在优先关系的终结符对产生了优先级关系，使原本能立即发现的错误向后推迟一段时间才被发现。" ] }, "LR分析器组成":{ "key":[ "LR分析器组成" ], "property":[ "subclassof" ], "to_name":[ "LR分析技术" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "一个输入串、一个分析栈、一张LR分析表、LR分析器总控程序。" ] }, "LR(k)技术的分类":{ "key":[ "LR(k)技术的分类" ], "property":[ "subclassof" ], "to_name":[ "LR分析技术" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "LR(0)分析法、SLR(1)分析法、LR(1)分析法、LALR(1)分析法。" ] }, "LALR(1)分析技术":{ "key":[ "LALR(1)分析技术" ], "property":[ "同义关系" ], "to_name":[ "SLR(1)分析技术" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ " 1）LALR(1)分析表的结构和大小与SLR(1)相同，比LR(1)的分析表小。2）LALR(1)的分析能力比SLR(1)强，比LR(1)稍弱。" ] }, "SLR(1)分析技术":{ "key":[ "SLR(1)分析技术" ], "property":[ "同义关系" ], "to_name":[ "自底向上的语法分析" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "含义：简化了的LR(1)分析技术。" ] }, "算符优先关系":{ "key":[ "算符优先关系" ], "property":[ "同义关系" ], "to_name":[ "自底向上的语法分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "1.算符文法  2.算符相邻  3.算符优先级 4.算符优先文法" ] }, "优先函数":{ "key":[ "优先函数" ], "property":[ "同义关系" ], "to_name":[ "自底向上的语法分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "1.目的：减小优先关系表的大小。2.基本思想：每一个运算符配上两个数。当终结符在左边出现时，配的数是f(a)；当a在右边出现时，配的数是g(a)，若每一个终结符都能如愿配上两个数，则优先关系表的大小就从n×n减小到2n。" ] }, "LR分析技术":{ "key":[ "LR分析技术" ], "property":[ "同义关系" ], "to_name":[ "自底向上的语法分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "1）L代表从左向右分析，R代表最右推导，k代表向前查看k个字符。  2）LR分析法实际上是最右推导的逆过程——最右归约。 3）LR(k)分析技术利用已经移进栈中的和归约后进入栈中的一切文法符号，并向前查看最多k个符号，从而确定句柄是否已经在栈顶形成，一旦句柄出现在栈顶，立即进行归约。" ] }, "自底向上的语法分析":{ "key":[ "自底向上的语法分析" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "1.工作方式：移进-归约。2.基本思想：将输入符号串中的符号从左向右逐个的移进栈，每当栈顶形成某一个可归约子串时，就把该可归约子串归约成某一个非终结符号。即先把该可归约子串从栈顶逐出，再把归约的非终结符号压进栈。" ] }, "三地址代码":{ "key":[ "三地址代码" ], "property":[ "subclassof" ], "to_name":[ "抽象语法树" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "1.形式：三地址代码的形式为x:=y op z。其中，y、z可以是名字、常数、临时变量等。X可以是名字或临时变量。op代表运算符。2.特点：式子右部只能有一个运算符。" ] }, "四元式":{ "key":[ "四元式" ], "property":[ "subclassof" ], "to_name":[ "抽象语法树" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "形式：四元式的形式是(op，arg1，arg2，result)。其中，op是运算符，arg1和arg2是操作对象，result存放最终结果。若op是单目运算符，则arg2可以省略。" ] }, "逆波兰式":{ "key":[ "逆波兰式" ], "property":[ "subclassof" ], "to_name":[ "抽象语法树" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "特点：操作数的先后次序不变，而运算符的先后次序是真正运算的先后次序。eg：将a*(b+c)翻译成逆波兰式代码：  abc+*" ] }, "三元式":{ "key":[ "三元式" ], "property":[ "subclassof" ], "to_name":[ "抽象语法树" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "形式：三元式的形式是( p )(op，arg1，org2)。其中op是运算符，arg1和arg2是操作对象。运算的结果由该三元式的位置( p )来引用。" ] }, "抽象语法树":{ "key":[ "抽象语法树" ], "property":[ "同义关系" ], "to_name":[ "语义分析" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "形式：将运算符、关键字作为树的内部结点，运算对象作为树的叶子结点，这样构成了一棵抽象语法树。" ] }, "图表示":{ "key":[ "图表示" ], "property":[ "同义关系" ], "to_name":[ "语义分析" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "形式：将表达式的运算符作为一个结点，操作数作为这个结点的子结点。当重复引用一个子表达式时，可直接重复使用这个子表达式所对应的结点。这样树形结构变成了有向无环图，简称DAG。" ] }, "语义分析":{ "key":[ "语义分析" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 7 ], "知识点描述":[ "主要任务：分析源程序的含义并做出相应的语义处理" ] }, "高级编程语言":{ "key":[ "高级编程语言" ], "property":[ "同义关系" ], "to_name":[ "机器语言" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "高级编程语言（High-level programming language）是高度封装了的编程语言，与低级语言相对。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。" ] }, "汇编语言":{ "key":[ "汇编语言" ], "property":[ "同义关系" ], "to_name":[ "机器语言" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。" ] }, "机器语言":{ "key":[ "机器语言" ], "property":[ "同义关系" ], "to_name":[ "符号常量" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "机器语言是机器能直接识别的程序语言或指令代码，勿需经过翻译，每一操作码在计算机内部都有相应的电路来完成它，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。机器语言使用绝对地址和绝对操作码。不同的计算机都有各自的机器语言，即指令系统。从使用的角度看，机器语言是最低级的语言。" ] }, "中间代码生成":{ "key":[ "中间代码生成" ], "property":[ "同义关系" ], "to_name":[ "符号常量" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "经过语法分析和语义分析后，许多编译器为源程序产生更低级的显示中间表示，可以理解为一种抽象的程序。" ] }, "数据复用":{ "key":[ "数据复用" ], "property":[ "同义关系" ], "to_name":[ "符号常量" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "对于局部性优化，我们希望识别出访问相同数据或相同高速缓存线的迭代集合。" ] }, "符号常量":{ "key":[ "符号常量" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 9 ], "知识点描述":[ "有时我们需要对涉及某些变量的循环嵌套结构进行优化，这些变量对于该嵌套中的所有循环都是循环不变的。我们把这样的变量称为符号常量( symbolic constant)。" ] }, "堆式存储分配策略":{ "key":[ "堆式存储分配策略" ], "property":[ "同义关系" ], "to_name":[ "静态存储分配策略" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "1.适用：对于指针类变量所指的空间采用堆式存储分配策略2.原因：指针变量所指的空间的大小和位置，有时只有在程序运行时才能知道。" ] }, "栈式存储分配策略":{ "key":[ "栈式存储分配策略" ], "property":[ "同义关系" ], "to_name":[ "静态存储分配策略" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "1.适用：对函数内部的非static型局部变量采用栈式存储分配策略。2.原因：函数可以直接或间接的递归调用。函数中的局部变量，可能出现多个实例。每递归调用一次，都会创建一个局部变量的实例。" ] }, "静态存储分配策略":{ "key":[ "静态存储分配策略" ], "property":[ "同义关系" ], "to_name":[ "运行时环境的组成" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "1.适用：对所有的static型局部变量和所有的全局变量采用静态存储分配策略。2.原因：全局变量及static型局部变量的大小在编译时就可以知道，而且无论程序中嵌套调用多少次，其变量永远只有一份。" ] }, "运行时环境的组成":{ "key":[ "运行时环境的组成" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 8 ], "知识点描述":[ "运行时刻存储空间的管理策略、符号表的管理、垃圾回收策略、运行支持库等。" ] }, "目标代码生成":{ "key":[ "目标代码生成" ], "property":[ "subclassof" ], "to_name":[ "编译程序的五个阶段" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "将中间代码变换成特定机器上的低级语言代码。" ] }, "代码优化":{ "key":[ "代码优化" ], "property":[ "subclassof" ], "to_name":[ "编译程序的五个阶段" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "遵循程序的等价变换规则。" ] }, "语义分析与中间代码生成":{ "key":[ "语义分析与中间代码生成" ], "property":[ "subclassof" ], "to_name":[ "编译程序的五个阶段" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "对各种语法范畴进行静态语义检查，若正确则进行中间代码翻译。" ] }, "语法分析":{ "key":[ "语法分析" ], "property":[ "subclassof" ], "to_name":[ "编译程序的五个阶段" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "根据语言的语法规则，把单词符号分解成各类语法单位。" ] }, "词法分析":{ "key":[ "词法分析" ], "property":[ "subclassof" ], "to_name":[ "编译程序的五个阶段" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "对源程序的字符串进行扫描和分解，识别出每个单词符号。" ] }, "编译程序的五个阶段":{ "key":[ "编译程序的五个阶段" ], "property":[ "同义关系" ], "to_name":[ "翻译程序的三种方式" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "词法分析、语法分析、语义分析与中间代码生成、代码优化、目标代码生成" ] }, "汇编":{ "key":[ "汇编" ], "property":[ "subclassof" ], "to_name":[ "翻译程序的三种方式" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "用汇编语言编写的源程序翻译成与之等价的机器语言。" ] }, "解释":{ "key":[ "解释" ], "property":[ "subclassof" ], "to_name":[ "翻译程序的三种方式" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "将高级语言编写的源程序翻译一句执行一句，不生成目标文件，直接执行源代码文件。" ] }, "编译":{ "key":[ "编译" ], "property":[ "subclassof" ], "to_name":[ "翻译程序的三种方式" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ "将高级语言编写的源程序翻译成等价的机器语言或汇编语言。" ] }, "翻译程序的三种方式":{ "key":[ "翻译程序的三种方式" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "编译、解释、汇编" ] }, "规范句型":{ "key":[ "规范句型" ], "property":[ "同义关系" ], "to_name":[ "最左推导" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "由规范推导得到的句型。" ] }, "最右推导(规范推导)":{ "key":[ "最右推导(规范推导)" ], "property":[ "同义关系" ], "to_name":[ "最左推导" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "对一个推导序列中的每一步直接推导α?β，都是对α中的最右非终结符进行替换。" ] }, "最左归约(规范归约)":{ "key":[ "最左归约(规范归约)" ], "property":[ "同义关系" ], "to_name":[ "最左推导" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "规范推导的逆过程。" ] }, "最左推导":{ "key":[ "最左推导" ], "property":[ "同义关系" ], "to_name":[ "短语" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "对一个推导序列中的每一步直接推导α?β，都是对α中的最左非终结符进行替换。" ] }, "句柄":{ "key":[ "句柄" ], "property":[ "同义关系" ], "to_name":[ "短语" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "一个句型的最左直接短语称为该句型的句柄。" ] }, "直接短语":{ "key":[ "直接短语" ], "property":[ "同义关系" ], "to_name":[ "短语" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "若存在Z ?+ αAδ且A?β，则称β是句型αβδ相对于产生式规则A→β的直接短语。" ] }, "文法的二义性":{ "key":[ "文法的二义性" ], "property":[ "同义关系" ], "to_name":[ "语法分析树" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "定义：若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的。特点：为编译程序的执行带来不确定性。" ] }, "二义性的消除":{ "key":[ "二义性的消除" ], "property":[ "同义关系" ], "to_name":[ "语法分析树" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "1、不改变文法：通过附加限制性条件消除二义性。寻找充分不必要条件，当文法满足这些条件时可确保文法是无二义性的。2.改变文法：改写原有文法，把排除二义性的规则合并到原文法消除二义性。" ] }, "文法的化简":{ "key":[ "文法的化简" ], "property":[ "同义关系" ], "to_name":[ "语法分析树" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "1.若一个非终结符不能推导出终结字符串，则该非终结符是无用的，删除所有包括该非终结符的产生式规则。2.若一个符号不能出现在文法的任何句型中，则该符号是无用的，删除所有包括该符号的产生式规则。" ] }, "语法分析树":{ "key":[ "语法分析树" ], "property":[ "同义关系" ], "to_name":[ "短语" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "一个句型推导过程的树形表示称为语法分析树，简称语法树。" ] }, "递归规则":{ "key":[ "递归规则" ], "property":[ "同义关系" ], "to_name":[ "推导" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "定义：一个产生式规则中，出现在左部的非终结符也出现在其右部。种类：左递归、右递归、递归。" ] }, "文法递归":{ "key":[ "文法递归" ], "property":[ "同义关系" ], "to_name":[ "推导" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "定义：对于文法中的任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现该终结符本身，则称文法是递归的。种类：左递归、右递归、递归。" ] }, "句型和句子":{ "key":[ "句型和句子" ], "property":[ "同义关系" ], "to_name":[ "推导" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "句型：若Z ?* x，x∈(VN∪VT)*，则称符号串x为文法G[Z]的句型。句子：若Z ?* x，x∈VT*，则称符号串x为文法G[Z]的句子。句子一定是句型，句型不一定是句子。" ] }, "短语":{ "key":[ "短语" ], "property":[ "同义关系" ], "to_name":[ "符号串和语言" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "若存在Z ?+ αAδ且A ?+ β，则称β是句型αβδ相对于非终结符A的短语。" ] }, "推导":{ "key":[ "推导" ], "property":[ "同义关系" ], "to_name":[ "符号串和语言" ], "重要程度":[ 3 ], "所属章节":[ 2 ], "知识点描述":[ "若存在一个直接推导序列：α0?α1?α2?…?αn，则称这个序列是一个从α0至αn的长度为n的推导。" ] }, "直接推导":{ "key":[ "直接推导" ], "property":[ "同义关系" ], "to_name":[ "产生式规则" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "令G=(VN，VT，P，Z)，若A→γ∈P，且α,β∈(VN∪VT)*，则称αAβ直接推导出αγβ，表示成αA ? βαγβ。" ] }, "文法":{ "key":[ "文法" ], "property":[ "同义关系" ], "to_name":[ "产生式规则" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "定义：产生式规则的非空有穷集合。由四元组G=(VN，VT，P，Z)组成。" ] }, "产生式规则":{ "key":[ "产生式规则" ], "property":[ "同义关系" ], "to_name":[ "符号串和语言" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "定义：一个产生式规则是一个有序对(A，α)。通常写作A→α或A::=α" ] }, "正闭包与闭包":{ "key":[ "正闭包与闭包" ], "property":[ "subclassof" ], "to_name":[ "符号串集合之间的运算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "设A是符号串的集合，则集合A的正闭包A+和闭包A*定义为A+ = A1∪A2∪…∪An∪…， A* = A0∪A1∪…∪An∪…" ] }, "幂运算":{ "key":[ "幂运算" ], "property":[ "subclassof" ], "to_name":[ "符号串集合之间的运算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "设A是符号串的集合，则A的幂运算定义为A0 = {ε}，A1 = A，An = AAn-1（n>0）" ] }, "乘积":{ "key":[ "乘积" ], "property":[ "subclassof" ], "to_name":[ "符号串集合之间的运算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "设A和B是符号串的集合，则A和B的乘积定义为AB = {xy | x∈A and y∈B}。" ] }, "并集":{ "key":[ "并集" ], "property":[ "subclassof" ], "to_name":[ "符号串集合之间的运算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "设A和B是符号串的集合，则A和B的并集定义为A∪B = {x | x∈A or x∈B}。" ] }, "符号串集合之间的运算":{ "key":[ "符号串集合之间的运算" ], "property":[ "同义关系" ], "to_name":[ "符号串和语言" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "并集、乘积、幂运算、正闭包与闭包" ] }, "3型语言(正规文法)":{ "key":[ "3型语言(正规文法)" ], "property":[ "subclassof" ], "to_name":[ "语言的分类" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "种类：右线性文法、左线性文法；特点：作为定义程序设计语言规则的文法" ] }, "2型文法(上下文无关文法)":{ "key":[ "2型文法(上下文无关文法)" ], "property":[ "subclassof" ], "to_name":[ "语言的分类" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "特点：语法结构上下文无关，一般用于识别程序设计语言的语法结构。" ] }, "1型文法(上下文敏感文法)":{ "key":[ "1型文法(上下文敏感文法)" ], "property":[ "subclassof" ], "to_name":[ "语言的分类" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "定义：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：αAβ→αvβ，其中α,β∈(VN∪VT)*，A∈VN，v∈(VN∪VT)+，则G[Z]为1型文法。" ] }, "0型文法(短语文法)":{ "key":[ "0型文法(短语文法)" ], "property":[ "subclassof" ], "to_name":[ "语言的分类" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "特点：0型文法的能力相当于图灵机，识别能力最强。" ] }, "语言的分类":{ "key":[ "语言的分类" ], "property":[ "同义关系" ], "to_name":[ "符号串和语言" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "0型文法(短语文法)、1型文法(上下文敏感文法)、2型文法(上下文无关文法)、3型语言(正规文法)" ] }, "语言":{ "key":[ "语言" ], "property":[ "subclassof" ], "to_name":[ "符号串和语言" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "定义：由字母表上的一些符号串组成的集合。说明：空集?是一个语言，仅含一个空符号串的集合{ε}也是一个语言。?和{ε}是不同的语言。" ] }, "符号串":{ "key":[ "符号串" ], "property":[ "subclassof" ], "to_name":[ "符号串和语言" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "定义：由字母表中的符号组成的有穷序列。表示：通常由t，u，v，w，x，y，z等小写英文字母来表示。" ] }, "字母表":{ "key":[ "字母表" ], "property":[ "subclassof" ], "to_name":[ "符号串和语言" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "定义：字母表是有穷非空的符号集合。表示：通常用字母表大写字母A，B，…Z和希腊字母Σ表示。" ] }, "符号串和语言":{ "key":[ "符号串和语言" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 1 ], "所属章节":[ 2 ], "知识点描述":[ "字母表、符号串、语言" ] }, "文件传输协议":{ "key":[ "文件传输协议" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。" ] }, "万维网":{ "key":[ "万维网" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "万维网WWW是World Wide Web的简称，也称为Web、3W等。WWW是基于客户机/服务器方式的信息发现技术和超文本技术的综合。" ] }, "网络应用模型":{ "key":[ "网络应用模型" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "包括客户服务器模型和P2P模型" ] }, "电子邮件":{ "key":[ "电子邮件" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "电子邮件是—种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。" ] }, "域名系统":{ "key":[ "域名系统" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。" ] }, "SMTP":{ "key":[ "SMTP" ], "property":[ "type" ], "to_name":[ "电子邮件" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。" ] }, "POP3":{ "key":[ "POP3" ], "property":[ "type" ], "to_name":[ "电子邮件" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。" ] }, "C/S模型":{ "key":[ "C/S模型" ], "property":[ "type" ], "to_name":[ "网络应用模型" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "服务器-客户机，即Client-Server(C/S)结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。" ] }, "P2P模型":{ "key":[ "P2P模型" ], "property":[ "type" ], "to_name":[ "网络应用模型" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "点对点技术又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上" ] }, "超文本传输协议":{ "key":[ "超文本传输协议" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。" ] }, "超文本标记语言":{ "key":[ "超文本标记语言" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "HTML称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。" ] }, "统一资源定位符":{ "key":[ "统一资源定位符" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "统一资源定位系统（uniform resource locator;URL）是因特网的万维网服务程序上用于指定信息位置的表示方法。" ] }, "IPV4":{ "key":[ "IPV4" ], "property":[ "type" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网际协议版本4（英语：InternetProtocolversion4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANAIPv4位址完全用尽时，IPv6仍处在部署的初期。" ] }, "IPV6":{ "key":[ "IPV6" ], "property":[ "type" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IPv6是英文“Internet Protocol Version 6”（互联网协议第6版）的缩写，是互联网工程任务组（IETF）设计的用于替代IPv4的下一代IP协议" ] }, "路由协议":{ "key":[ "路由协议" ], "property":[ "前驱关系" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "路由协议（英语：Routing protocol）是一种指定数据包转送方式的网上协议。Internet网络的主要节点设备是路由器，路由器通过路由表来转发接收到的数据。" ] }, "无分类编址CIDR":{ "key":[ "无分类编址CIDR" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ "无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。" ] }, "子网划分":{ "key":[ "子网划分" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "子网划分定义：Internet组织机构定义了五种IP地址，有A、B、C三类地址。" ] }, "子网掩码":{ "key":[ "子网掩码" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。" ] }, "IPV4地址与NAT":{ "key":[ "IPV4地址与NAT" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "协议":{ "key":[ "协议" ], "property":[ "前驱关系" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "动态主机配置协议DHCP":{ "key":[ "动态主机配置协议DHCP" ], "property":[ "type" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。" ] }, "地址解析协议ARP":{ "key":[ "地址解析协议ARP" ], "property":[ "type" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；" ] }, "IPV4地址":{ "key":[ "IPV4地址" ], "property":[ "subclassof" ], "to_name":[ "IPV4地址与NAT" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "无论你是使用智能手机上网还是使用PC机上网，你的手机或PC机都会被分配一个IP地址，手机或PC机使用这个IP地址与互联网上的其它网络通信并进行信息交换。" ] }, "网络地址转换":{ "key":[ "网络地址转换" ], "property":[ "subclassof" ], "to_name":[ "IPV4地址与NAT" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。" ] }, "自治系统":{ "key":[ "自治系统" ], "property":[ "前驱关系" ], "to_name":[ "路由协议" ], "重要程度":[ 1 ], "所属章节":[ "4" ], "知识点描述":[ "自治系统：autonomous system。在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。" ] }, "内部网关协议IGP":{ "key":[ "内部网关协议IGP" ], "property":[ "type" ], "to_name":[ "路由协议" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IGP（内部网关协议）是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。" ] }, "外部网关协议EGP":{ "key":[ "外部网关协议EGP" ], "property":[ "type" ], "to_name":[ "路由协议" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "EGP是一种简单的（网络）可达性协议，其与现代的距离-矢量协议和路径-矢量协议不同，它仅限适用于树状拓扑的网络。" ] }, "BGP协议":{ "key":[ "BGP协议" ], "property":[ "type" ], "to_name":[ "外部网关协议EGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议" ] }, "RIP协议":{ "key":[ "RIP协议" ], "property":[ "type" ], "to_name":[ "内部网关协议IGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "RIP(Routing Information Protocol,路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。" ] }, "OSPF协议":{ "key":[ "OSPF协议" ], "property":[ "type" ], "to_name":[ "内部网关协议IGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。" ] }, "网际协议IP":{ "key":[ "网际协议IP" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IP只为主机提供一种无连接、不可靠的、尽力而为的数据报传输服务。" ] }, "两种服务":{ "key":[ "两种服务" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "功能":{ "key":[ "功能" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "虚电路服务":{ "key":[ "虚电路服务" ], "property":[ "type" ], "to_name":[ "两种服务" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "虚电路服务是指是一种面向连接的，使所有分组顺序到达目的端的可 靠性数据传输服务。" ] }, "数据报服务":{ "key":[ "数据报服务" ], "property":[ "type" ], "to_name":[ "两种服务" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "数据报服务是由数据报交换网来提供。端系统的网络层同网络节点中的网络层之间，一致地按照数据报操作方式交换数据。" ] }, "异构网络互联":{ "key":[ "异构网络互联" ], "property":[ "subclassof" ], "to_name":[ "功能" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ "异构网络(Heterogeneous Network）是一种类型的网络，其是由不同制造商生产的计算机，网络设备和系统组成的，大部分情况下运行在不同的协议上支持不同的功能或应用。" ] }, "路由与转发":{ "key":[ "路由与转发" ], "property":[ "subclassof" ], "to_name":[ "功能" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "拥塞控制":{ "key":[ "拥塞控制" ], "property":[ "type" ], "to_name":[ "TCP功能" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。" ] }, "可靠传输机制":{ "key":[ "可靠传输机制" ], "property":[ "type" ], "to_name":[ "TCP功能" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "流量控制":{ "key":[ "流量控制" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "网络流量控制（Network traffic control）是利用软件或硬件方式来实现对网络数据流量进行控制的一种措施。" ] }, "TCP功能":{ "key":[ "TCP功能" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "TCP连接管理":{ "key":[ "TCP连接管理" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "TCP报文段":{ "key":[ "TCP报文段" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ "报文段 [1]  .是指TCP/IP协议网络传输过程中，起着路由导航，查询各个网络路由网段,IP地址，交换协议等IP数据包。报文段充当整个TCP/IP协议数据包的导航路由功能。" ] }, "传输层":{ "key":[ "传输层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "传输层是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务。" ] }, "UDP校验":{ "key":[ "UDP校验" ], "property":[ "前驱关系" ], "to_name":[ "UDP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "网络层":{ "key":[ "网络层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网络层位于物联网三层结构中的第二层，其功能为“传送”，即通过通信网络进行信息传输。" ] }, "应用层":{ "key":[ "应用层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "应用层是开放系统的最高层,是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时,完成一系列业务处理所需的服务." ] }, "数据链路层":{ "key":[ "数据链路层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间。数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。" ] }, "设备":{ "key":[ "设备" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "组帧":{ "key":[ "组帧" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "组帧bai就是把相关的信息资料组合在一起成为可以在网络du上传输zhi的数据" ] }, "介质访问":{ "key":[ "介质访问" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "介质访问控制(medium access control)简称MAC。 是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。" ] }, "可靠传输":{ "key":[ "可靠传输" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "传输技术 指充分利用不同信道的传输能力构成一个完整的传输系统，使信息得以可靠传输的技术。传输系统是通信系统的重要组成部分，传输技术主要依赖于具体信道的传输特性。" ] }, "差错控制":{ "key":[ "差错控制" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "差错控制（error control）是在数字通信中利用编码方法对传输中产生的差错进行控制，以提高数字消息传输的准确性。" ] }, "随机访问":{ "key":[ "随机访问" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "轮询访问":{ "key":[ "轮询访问" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "轮询访问技术是一种受控访问技术。在由多个结点共享公用信道的线路中，主机依照一定的顺序探询各结点有无传送信息的要求，被探询的结点如有传送要求就占用公用信道，将信息发送给主机否则，主机继续探询下一结点。" ] }, "信道划分":{ "key":[ "信道划分" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "码分复用":{ "key":[ "码分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "码分复用是用一组包含互相正交的码字的码组携带多路信号。采用同一波长的扩频序列，频谱资源利用率高，与WDM结合，可以大大增加系统容量。" ] }, "频分复用":{ "key":[ "频分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "频分复用(FDM，Frequency Division Multiplexing)就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输1路信号。" ] }, "时分复用":{ "key":[ "时分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "时分复用TDM是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的目的。" ] }, "波分复用":{ "key":[ "波分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "波分复用WDM(Wavelength Division Multiplexing)是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；" ] }, "CSMA/CD协议":{ "key":[ "CSMA/CD协议" ], "property":[ "subclassof" ], "to_name":[ "随机访问" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "CSMA/CD即载波侦听多路访问/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点。" ] }, "集线器":{ "key":[ "集线器" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "集线器的英文称为“Hub”。“Hub”是“中心”的意思，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。" ] }, "交换机":{ "key":[ "交换机" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。" ] }, "网桥":{ "key":[ "网桥" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。" ] }, "物理层":{ "key":[ "物理层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ "物理层（或称物理层，Physical Layer）是计算机网络OSI模型中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。" ] }, "传输介质":{ "key":[ "传输介质" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ "网络传输介质是指在网络中传输信息的载体，常用的传输介质分为有线传输介质和无线传输介质两大类。" ] }, "通信基础":{ "key":[ "通信基础" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "体系结构":{ "key":[ "体系结构" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ "2，3，4，5，6" ], "知识点描述":[ ] }, "具体应用":{ "key":[ "具体应用" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ ] }, "基本概念":{ "key":[ "基本概念" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "网络安全":{ "key":[ "网络安全" ], "property":[ "subclassof" ], "to_name":[ "具体应用" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "网络安全是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断" ] }, "互联网的组成":{ "key":[ "互联网的组成" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "核心部分":{ "key":[ "核心部分" ], "property":[ "type" ], "to_name":[ "互联网的组成" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "边缘部分":{ "key":[ "边缘部分" ], "property":[ "type" ], "to_name":[ "互联网的组成" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "计算机网络性能指标":{ "key":[ "计算机网络性能指标" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 3 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "速率":{ "key":[ "速率" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "吞吐量":{ "key":[ "吞吐量" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "吞吐量是指网络中主机（server和client）之间的实际数据传输速率，即单位时间内实际传输的数据量，常用的单位有Kbps,Mbps。" ] }, "往返时间RTT":{ "key":[ "往返时间RTT" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间。" ] }, "计算机网络类别":{ "key":[ "计算机网络类别" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "个人区域网":{ "key":[ "个人区域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "个人局域网（英语：Personal Area Network，缩写为PAN），指个人范围（随身携带或数米之内）的计算设备（如计算机、电话、PDA、数字相机等）组成的通信网络。" ] }, "城域网":{ "key":[ "城域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "城域网(Metropolitan Area Network)是在一个城市范围内所建立的计算机通信网，简称MAN。属宽带局域网。" ] }, "局域网":{ "key":[ "局域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛" ] }, "广域网":{ "key":[ "广域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "广域网（英语：Wide Area Network，缩写为 WAN），又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。" ] }, "带宽":{ "key":[ "带宽" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "带宽是指网络的最大数据传输速率，常用单位也是Kbps,Mbps。" ] }, "信道利用率":{ "key":[ "信道利用率" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "信道利用率是指发送时延除以发送时延加上往返传输时延" ] }, "传输方式":{ "key":[ "传输方式" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "定理":{ "key":[ "定理" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "信道":{ "key":[ "信道" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "指通信的通道，是信号传输的媒介" ] }, "调制与解码":{ "key":[ "调制与解码" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "调制就是用基带信号去控制载波信号的某个或几个参量的变化，将信息荷载在其上形成已调信号传输，而解调是调制的反过程，通过具体的方法从已调信号的参量变化中将恢复原始的基带信号。" ] }, "全双工":{ "key":[ "全双工" ], "property":[ "type" ], "to_name":[ "信道" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。" ] }, "半双工":{ "key":[ "半双工" ], "property":[ "type" ], "to_name":[ "信道" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。" ] }, "分组交换":{ "key":[ "分组交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。" ] }, "报文交换":{ "key":[ "报文交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "报文交换（英语：Message switching），又称存储转发交换，是数据交换的三种方式之一，报文整个地发送，一次一跳。" ] }, "电路交换":{ "key":[ "电路交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "电路交换（CS:circuit switching）是通信网中最早出现的一种交换方式，也是应用最普遍的一种交换方式，主要应用于电话通信网中，完成电话交换" ] }, "数据报":{ "key":[ "数据报" ], "property":[ "type" ], "to_name":[ "分组交换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "数据报是通过网络传输的数据的基本单元，包含一个报头（header）和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。" ] }, "虚电路":{ "key":[ "虚电路" ], "property":[ "type" ], "to_name":[ "分组交换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "虚电路是分组交换的两种传输方式中的一种。在通信和网络中，虚电路是由分组交换通信所提供的面向连接的通信服务。" ] }, "文件传输协议":{ "key":[ "文件传输协议" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。" ] }, "万维网":{ "key":[ "万维网" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "万维网WWW是World Wide Web的简称，也称为Web、3W等。WWW是基于客户机/服务器方式的信息发现技术和超文本技术的综合。" ] }, "网络应用模型":{ "key":[ "网络应用模型" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "包括客户服务器模型和P2P模型" ] }, "电子邮件":{ "key":[ "电子邮件" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "电子邮件是—种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。" ] }, "域名系统":{ "key":[ "域名系统" ], "property":[ "subclassof" ], "to_name":[ "应用层" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。" ] }, "SMTP":{ "key":[ "SMTP" ], "property":[ "type" ], "to_name":[ "电子邮件" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。" ] }, "POP3":{ "key":[ "POP3" ], "property":[ "type" ], "to_name":[ "电子邮件" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。" ] }, "C/S模型":{ "key":[ "C/S模型" ], "property":[ "type" ], "to_name":[ "网络应用模型" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "服务器-客户机，即Client-Server(C/S)结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。" ] }, "P2P模型":{ "key":[ "P2P模型" ], "property":[ "type" ], "to_name":[ "网络应用模型" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "点对点技术又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上" ] }, "超文本传输协议":{ "key":[ "超文本传输协议" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。" ] }, "超文本标记语言":{ "key":[ "超文本标记语言" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "HTML称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。" ] }, "统一资源定位符":{ "key":[ "统一资源定位符" ], "property":[ "subclassof" ], "to_name":[ "万维网" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "统一资源定位系统（uniform resource locator;URL）是因特网的万维网服务程序上用于指定信息位置的表示方法。" ] }, "IPV4":{ "key":[ "IPV4" ], "property":[ "type" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网际协议版本4（英语：InternetProtocolversion4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANAIPv4位址完全用尽时，IPv6仍处在部署的初期。" ] }, "IPV6":{ "key":[ "IPV6" ], "property":[ "type" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IPv6是英文“Internet Protocol Version 6”（互联网协议第6版）的缩写，是互联网工程任务组（IETF）设计的用于替代IPv4的下一代IP协议" ] }, "路由协议":{ "key":[ "路由协议" ], "property":[ "前驱关系" ], "to_name":[ "网际协议IP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "路由协议（英语：Routing protocol）是一种指定数据包转送方式的网上协议。Internet网络的主要节点设备是路由器，路由器通过路由表来转发接收到的数据。" ] }, "无分类编址CIDR":{ "key":[ "无分类编址CIDR" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ "无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。" ] }, "子网划分":{ "key":[ "子网划分" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "子网划分定义：Internet组织机构定义了五种IP地址，有A、B、C三类地址。" ] }, "子网掩码":{ "key":[ "子网掩码" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。" ] }, "IPV4地址与NAT":{ "key":[ "IPV4地址与NAT" ], "property":[ "subclassof" ], "to_name":[ "IPV4" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "协议":{ "key":[ "协议" ], "property":[ "前驱关系" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "动态主机配置协议DHCP":{ "key":[ "动态主机配置协议DHCP" ], "property":[ "type" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。" ] }, "地址解析协议ARP":{ "key":[ "地址解析协议ARP" ], "property":[ "type" ], "to_name":[ "IPV4" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；" ] }, "IPV4地址":{ "key":[ "IPV4地址" ], "property":[ "subclassof" ], "to_name":[ "IPV4地址与NAT" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "无论你是使用智能手机上网还是使用PC机上网，你的手机或PC机都会被分配一个IP地址，手机或PC机使用这个IP地址与互联网上的其它网络通信并进行信息交换。" ] }, "网络地址转换":{ "key":[ "网络地址转换" ], "property":[ "subclassof" ], "to_name":[ "IPV4地址与NAT" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。" ] }, "自治系统":{ "key":[ "自治系统" ], "property":[ "前驱关系" ], "to_name":[ "路由协议" ], "重要程度":[ 1 ], "所属章节":[ "4" ], "知识点描述":[ "自治系统：autonomous system。在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。" ] }, "内部网关协议IGP":{ "key":[ "内部网关协议IGP" ], "property":[ "type" ], "to_name":[ "路由协议" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IGP（内部网关协议）是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。" ] }, "外部网关协议EGP":{ "key":[ "外部网关协议EGP" ], "property":[ "type" ], "to_name":[ "路由协议" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "EGP是一种简单的（网络）可达性协议，其与现代的距离-矢量协议和路径-矢量协议不同，它仅限适用于树状拓扑的网络。" ] }, "BGP协议":{ "key":[ "BGP协议" ], "property":[ "type" ], "to_name":[ "外部网关协议EGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议" ] }, "RIP协议":{ "key":[ "RIP协议" ], "property":[ "type" ], "to_name":[ "内部网关协议IGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "RIP(Routing Information Protocol,路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。" ] }, "OSPF协议":{ "key":[ "OSPF协议" ], "property":[ "type" ], "to_name":[ "内部网关协议IGP" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。" ] }, "网际协议IP":{ "key":[ "网际协议IP" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "IP只为主机提供一种无连接、不可靠的、尽力而为的数据报传输服务。" ] }, "两种服务":{ "key":[ "两种服务" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "功能":{ "key":[ "功能" ], "property":[ "subclassof" ], "to_name":[ "网络层" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "虚电路服务":{ "key":[ "虚电路服务" ], "property":[ "type" ], "to_name":[ "两种服务" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "虚电路服务是指是一种面向连接的，使所有分组顺序到达目的端的可 靠性数据传输服务。" ] }, "数据报服务":{ "key":[ "数据报服务" ], "property":[ "type" ], "to_name":[ "两种服务" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "数据报服务是由数据报交换网来提供。端系统的网络层同网络节点中的网络层之间，一致地按照数据报操作方式交换数据。" ] }, "异构网络互联":{ "key":[ "异构网络互联" ], "property":[ "subclassof" ], "to_name":[ "功能" ], "重要程度":[ 2 ], "所属章节":[ "4" ], "知识点描述":[ "异构网络(Heterogeneous Network）是一种类型的网络，其是由不同制造商生产的计算机，网络设备和系统组成的，大部分情况下运行在不同的协议上支持不同的功能或应用。" ] }, "路由与转发":{ "key":[ "路由与转发" ], "property":[ "subclassof" ], "to_name":[ "功能" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ ] }, "拥塞控制":{ "key":[ "拥塞控制" ], "property":[ "type" ], "to_name":[ "TCP功能" ], "重要程度":[ 3 ], "所属章节":[ "4" ], "知识点描述":[ "拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。" ] }, "可靠传输机制":{ "key":[ "可靠传输机制" ], "property":[ "type" ], "to_name":[ "TCP功能" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "流量控制":{ "key":[ "流量控制" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "网络流量控制（Network traffic control）是利用软件或硬件方式来实现对网络数据流量进行控制的一种措施。" ] }, "TCP功能":{ "key":[ "TCP功能" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "TCP连接管理":{ "key":[ "TCP连接管理" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 1 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "TCP报文段":{ "key":[ "TCP报文段" ], "property":[ "前驱关系" ], "to_name":[ "TCP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ "报文段 [1]  .是指TCP/IP协议网络传输过程中，起着路由导航，查询各个网络路由网段,IP地址，交换协议等IP数据包。报文段充当整个TCP/IP协议数据包的导航路由功能。" ] }, "传输层":{ "key":[ "传输层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "5" ], "知识点描述":[ "传输层是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务。" ] }, "UDP校验":{ "key":[ "UDP校验" ], "property":[ "前驱关系" ], "to_name":[ "UDP协议" ], "重要程度":[ 2 ], "所属章节":[ "5" ], "知识点描述":[ ] }, "网络层":{ "key":[ "网络层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "4" ], "知识点描述":[ "网络层位于物联网三层结构中的第二层，其功能为“传送”，即通过通信网络进行信息传输。" ] }, "应用层":{ "key":[ "应用层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "应用层是开放系统的最高层,是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时,完成一系列业务处理所需的服务." ] }, "数据链路层":{ "key":[ "数据链路层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间。数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。" ] }, "设备":{ "key":[ "设备" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "组帧":{ "key":[ "组帧" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "组帧bai就是把相关的信息资料组合在一起成为可以在网络du上传输zhi的数据" ] }, "介质访问":{ "key":[ "介质访问" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "介质访问控制(medium access control)简称MAC。 是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。" ] }, "可靠传输":{ "key":[ "可靠传输" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "传输技术 指充分利用不同信道的传输能力构成一个完整的传输系统，使信息得以可靠传输的技术。传输系统是通信系统的重要组成部分，传输技术主要依赖于具体信道的传输特性。" ] }, "差错控制":{ "key":[ "差错控制" ], "property":[ "subclassof" ], "to_name":[ "数据链路层" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "差错控制（error control）是在数字通信中利用编码方法对传输中产生的差错进行控制，以提高数字消息传输的准确性。" ] }, "随机访问":{ "key":[ "随机访问" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "轮询访问":{ "key":[ "轮询访问" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "轮询访问技术是一种受控访问技术。在由多个结点共享公用信道的线路中，主机依照一定的顺序探询各结点有无传送信息的要求，被探询的结点如有传送要求就占用公用信道，将信息发送给主机否则，主机继续探询下一结点。" ] }, "信道划分":{ "key":[ "信道划分" ], "property":[ "type" ], "to_name":[ "介质访问" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ ] }, "码分复用":{ "key":[ "码分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "码分复用是用一组包含互相正交的码字的码组携带多路信号。采用同一波长的扩频序列，频谱资源利用率高，与WDM结合，可以大大增加系统容量。" ] }, "频分复用":{ "key":[ "频分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "频分复用(FDM，Frequency Division Multiplexing)就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输1路信号。" ] }, "时分复用":{ "key":[ "时分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "时分复用TDM是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的目的。" ] }, "波分复用":{ "key":[ "波分复用" ], "property":[ "type" ], "to_name":[ "信道划分" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "波分复用WDM(Wavelength Division Multiplexing)是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；" ] }, "CSMA/CD协议":{ "key":[ "CSMA/CD协议" ], "property":[ "subclassof" ], "to_name":[ "随机访问" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "CSMA/CD即载波侦听多路访问/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点。" ] }, "集线器":{ "key":[ "集线器" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "集线器的英文称为“Hub”。“Hub”是“中心”的意思，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。" ] }, "交换机":{ "key":[ "交换机" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。" ] }, "网桥":{ "key":[ "网桥" ], "property":[ "subclassof" ], "to_name":[ "设备" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。" ] }, "物理层":{ "key":[ "物理层" ], "property":[ "subclassof" ], "to_name":[ "体系结构" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ "物理层（或称物理层，Physical Layer）是计算机网络OSI模型中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。" ] }, "传输介质":{ "key":[ "传输介质" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ "网络传输介质是指在网络中传输信息的载体，常用的传输介质分为有线传输介质和无线传输介质两大类。" ] }, "通信基础":{ "key":[ "通信基础" ], "property":[ "subclassof" ], "to_name":[ "物理层" ], "重要程度":[ 1 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "体系结构":{ "key":[ "体系结构" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ "2，3，4，5，6" ], "知识点描述":[ ] }, "具体应用":{ "key":[ "具体应用" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ "7" ], "知识点描述":[ ] }, "基本概念":{ "key":[ "基本概念" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "网络安全":{ "key":[ "网络安全" ], "property":[ "subclassof" ], "to_name":[ "具体应用" ], "重要程度":[ 2 ], "所属章节":[ "7" ], "知识点描述":[ "网络安全是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断" ] }, "互联网的组成":{ "key":[ "互联网的组成" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "核心部分":{ "key":[ "核心部分" ], "property":[ "type" ], "to_name":[ "互联网的组成" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "边缘部分":{ "key":[ "边缘部分" ], "property":[ "type" ], "to_name":[ "互联网的组成" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "计算机网络性能指标":{ "key":[ "计算机网络性能指标" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 3 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "速率":{ "key":[ "速率" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "吞吐量":{ "key":[ "吞吐量" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "吞吐量是指网络中主机（server和client）之间的实际数据传输速率，即单位时间内实际传输的数据量，常用的单位有Kbps,Mbps。" ] }, "往返时间RTT":{ "key":[ "往返时间RTT" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间。" ] }, "计算机网络类别":{ "key":[ "计算机网络类别" ], "property":[ "subclassof" ], "to_name":[ "基本概念" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ ] }, "个人区域网":{ "key":[ "个人区域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "个人局域网（英语：Personal Area Network，缩写为PAN），指个人范围（随身携带或数米之内）的计算设备（如计算机、电话、PDA、数字相机等）组成的通信网络。" ] }, "城域网":{ "key":[ "城域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "城域网(Metropolitan Area Network)是在一个城市范围内所建立的计算机通信网，简称MAN。属宽带局域网。" ] }, "局域网":{ "key":[ "局域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛" ] }, "广域网":{ "key":[ "广域网" ], "property":[ "type" ], "to_name":[ "计算机网络类别" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "广域网（英语：Wide Area Network，缩写为 WAN），又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。" ] }, "带宽":{ "key":[ "带宽" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "带宽是指网络的最大数据传输速率，常用单位也是Kbps,Mbps。" ] }, "信道利用率":{ "key":[ "信道利用率" ], "property":[ "type" ], "to_name":[ "计算机网络性能指标" ], "重要程度":[ 2 ], "所属章节":[ "1" ], "知识点描述":[ "信道利用率是指发送时延除以发送时延加上往返传输时延" ] }, "传输方式":{ "key":[ "传输方式" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "定理":{ "key":[ "定理" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ ] }, "信道":{ "key":[ "信道" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "指通信的通道，是信号传输的媒介" ] }, "调制与解码":{ "key":[ "调制与解码" ], "property":[ "subclassof" ], "to_name":[ "通信基础" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "调制就是用基带信号去控制载波信号的某个或几个参量的变化，将信息荷载在其上形成已调信号传输，而解调是调制的反过程，通过具体的方法从已调信号的参量变化中将恢复原始的基带信号。" ] }, "全双工":{ "key":[ "全双工" ], "property":[ "type" ], "to_name":[ "信道" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。" ] }, "半双工":{ "key":[ "半双工" ], "property":[ "type" ], "to_name":[ "信道" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。" ] }, "分组交换":{ "key":[ "分组交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。" ] }, "报文交换":{ "key":[ "报文交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "报文交换（英语：Message switching），又称存储转发交换，是数据交换的三种方式之一，报文整个地发送，一次一跳。" ] }, "电路交换":{ "key":[ "电路交换" ], "property":[ "type" ], "to_name":[ "传输方式" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "电路交换（CS:circuit switching）是通信网中最早出现的一种交换方式，也是应用最普遍的一种交换方式，主要应用于电话通信网中，完成电话交换" ] }, "数据报":{ "key":[ "数据报" ], "property":[ "type" ], "to_name":[ "分组交换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "数据报是通过网络传输的数据的基本单元，包含一个报头（header）和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。" ] }, "虚电路":{ "key":[ "虚电路" ], "property":[ "type" ], "to_name":[ "分组交换" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "虚电路是分组交换的两种传输方式中的一种。在通信和网络中，虚电路是由分组交换通信所提供的面向连接的通信服务。" ] }, "二叉树的遍历":{ "key":[ "二叉树的遍历" ], "property":[ "前驱关系" ], "to_name":[ "二叉树" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。" ] }, "先序遍历二叉树":{ "key":[ "先序遍历二叉树" ], "property":[ "subclassof" ], "to_name":[ "二叉树的遍历" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "先序遍历(Pre-order)，按照根左右的顺序沿一定路径经过路径上所有的结点。在二叉树中，先根后左再右。巧记：根左右。" ] }, "中序遍历二叉树":{ "key":[ "中序遍历二叉树" ], "property":[ "subclassof" ], "to_name":[ "二叉树的遍历" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "中序遍历(LDR)是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。巧记：左根右。" ] }, "后序遍历二叉树":{ "key":[ "后序遍历二叉树" ], "property":[ "subclassof" ], "to_name":[ "二叉树的遍历" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "后序遍历(LRD)是二叉树遍历的一种，也叫做后根遍历、后序周游。后序遍历有递归算法和非递归算法两种。巧记：左右根。" ] }, "图的遍历":{ "key":[ "图的遍历" ], "property":[ "前驱关系" ], "to_name":[ "图状结构" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "图的遍历指的是从图中的任一顶点出发，对图中的所有顶点访问一次且只访问一次。" ] }, "深度优先搜索":{ "key":[ "深度优先搜索" ], "property":[ "type" ], "to_name":[ "图的遍历" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "深度优先搜索，其别名又叫DFS，属于图算法的一种。利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。" ] }, "广度优先搜索":{ "key":[ "广度优先搜索" ], "property":[ "type" ], "to_name":[ "图的遍历" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "广度优先搜索，其别名又叫BFS，属于一种盲目搜寻法，是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。" ] }, "树的遍历":{ "key":[ "树的遍历" ], "property":[ "前驱关系" ], "to_name":[ "树" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次。树的3种最重要的遍历方式分别称为前序遍历、中序遍历和后序遍历。" ] }, "先根遍历树":{ "key":[ "先根遍历树" ], "property":[ "subclassof" ], "to_name":[ "树的遍历" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "先根遍历，也叫先序遍历，遍历的顺序是，根，左子树，右子树" ] }, "中根遍历树":{ "key":[ "中根遍历树" ], "property":[ "subclassof" ], "to_name":[ "树的遍历" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "中根遍历，也叫中序遍历，顺序是左子树、根、右子树。" ] }, "后根遍历树":{ "key":[ "后根遍历树" ], "property":[ "subclassof" ], "to_name":[ "树的遍历" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "后根遍历，也叫后序遍历，遍历顺序是左子树、右子树、根。" ] }, "线索二叉树":{ "key":[ "线索二叉树" ], "property":[ "type" ], "to_name":[ "基本操作" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。" ] }, "先序线索二叉树":{ "key":[ "先序线索二叉树" ], "property":[ "type" ], "to_name":[ "线索二叉树" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "在先序线索二叉树中查找结点的后继较容易，而查找前驱要知道其双亲的信息，要使用栈，所以说先序线索二叉树是不完善的。" ] }, "中序线索二叉树":{ "key":[ "中序线索二叉树" ], "property":[ "type" ], "to_name":[ "线索二叉树" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "若结点的ltag=1，lchild指向其前驱;否则，该结点的前驱是以该结点为根的左子树上按中序遍历的最后一个结点。若rtag=1，rchild指向其后继;否则，该结点的后继是以该结点为根的右子树上按中序遍历的第一个结点。" ] }, "后序线索二叉树":{ "key":[ "后序线索二叉树" ], "property":[ "type" ], "to_name":[ "线索二叉树" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "在后序线索二叉树中查找结点*p的前驱:若结点*p无左子树，则p->lchild指向其前驱;否则，若结点*p有左子树，当其右子树为空时，其左子树的根(即p->lrchild)为其后序前驱。当其右子树非空时，其右子树的根(即p->rchild)为其后序前驱。" ] }, "二叉树":{ "key":[ "二叉树" ], "property":[ "type" ], "to_name":[ "树形结构" ], "重要程度":[ 6 ], "所属章节":[ "4" ], "知识点描述":[ "一棵二叉树是节点的一个有限集合。" ] }, "平衡二叉树":{ "key":[ "平衡二叉树" ], "property":[ "type" ], "to_name":[ "二叉树" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "当且仅当任何节点的两棵子树的高度差不大于1的二叉树。" ] }, "二叉排序树":{ "key":[ "二叉排序树" ], "property":[ "type" ], "to_name":[ "二叉树" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "一棵空树，或者是具有下列性质的二叉树：（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）左、右子树也分别为二叉排序树；（4）没有键值相等的结点。" ] }, "一般二叉树":{ "key":[ "一般二叉树" ], "property":[ "type" ], "to_name":[ "二叉树" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "一棵二叉树是节点的一个有限集合,该集合或者为空,或者由一个根节点加上两棵左子树和右子树组成。" ] }, "满二叉树":{ "key":[ "满二叉树" ], "property":[ "type" ], "to_name":[ "二叉树" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上" ] }, "赫夫曼树":{ "key":[ "赫夫曼树" ], "property":[ "同义关系" ], "to_name":[ "最优二叉树" ], "重要程度":[ 4 ], "所属章节":[ "6" ], "知识点描述":[ "哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。" ] }, "完全二叉树":{ "key":[ "完全二叉树" ], "property":[ "type" ], "to_name":[ "二叉树" ], "重要程度":[ 2 ], "所属章节":[ "6" ], "知识点描述":[ "若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。" ] }, "最优二叉树":{ "key":[ "最优二叉树" ], "property":[ "type" ], "to_name":[ "二叉树" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。" ] }, "森林":{ "key":[ "森林" ], "property":[ "type" ], "to_name":[ "树形结构" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "森林(forest)是m(m≥0)棵互不相交的树的集合。任何一棵树，删除了根结点就变成了森林。" ] }, "树":{ "key":[ "树" ], "property":[ "type" ], "to_name":[ "树形结构" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "树(tree)是n(n>0)个节点的有限集，在任意一棵树中，(1)有且仅有一个特定的称为根(root)的节点，(2)当n>1时，其余节点可分为m(m>0)个互不相交的有限集，而每个集合本身又是一棵树，称为根的子树(subtree)。" ] }, "一般树":{ "key":[ "一般树" ], "property":[ "type" ], "to_name":[ "树" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。" ] }, "B-树":{ "key":[ "B-树" ], "property":[ "type" ], "to_name":[ "树" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有最多2个子节点。" ] }, "键树":{ "key":[ "键树" ], "property":[ "type" ], "to_name":[ "树" ], "重要程度":[ 1 ], "所属章节":[ "6" ], "知识点描述":[ "如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。" ] }, "B+树":{ "key":[ "B+树" ], "property":[ "type" ], "to_name":[ "树" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "B+ 树是一种树数据结构，通常用于关系型数据库（如Mysql）和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。" ] }, "树形结构":{ "key":[ "树形结构" ], "property":[ "type" ], "to_name":[ "存储结构" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "树形结构是一层次的嵌套结构。 一个树形结构的外层和内层有相似的结构， 所以这种结构多可以递归的表示。经典数据结构中的各种树状图是一种典型的树形结构：一颗树可以简单的表示为根， 左子树， 右子树。 左子树和右子树又有自己的子树。" ] }, "线性结构":{ "key":[ "线性结构" ], "property":[ "type" ], "to_name":[ "存储结构" ], "重要程度":[ 3 ], "所属章节":[ "2" ], "知识点描述":[ "线性结构是一个有序数据元素的集合。常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。" ] }, "集合":{ "key":[ "集合" ], "property":[ "type" ], "to_name":[ "存储结构" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "list集合是线性数据结构的主要表现，集合元素通常明确的上一个和下一个元素，也存在明确的第一个元素和最后一个元素。" ] }, "图状结构":{ "key":[ "图状结构" ], "property":[ "type" ], "to_name":[ "存储结构" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "图状结构是多对多关系形成的逻辑结构。其中每个元素的直接前趋和直接后继数目都不限。" ] }, "数组":{ "key":[ "数组" ], "property":[ "type" ], "to_name":[ "线性结构" ], "重要程度":[ 3 ], "所属章节":[ "5" ], "知识点描述":[ "所谓数组，是有序的元素序列。" ] }, "广义表":{ "key":[ "广义表" ], "property":[ "type" ], "to_name":[ "线性结构" ], "重要程度":[ 3 ], "所属章节":[ "5" ], "知识点描述":[ "广义表(Lists，又称列表)是一种非线性的数据结构，是线性表的一种推广。即广义表中放松对表元素的原子限制，容许它们具有其自身结构。广义表定义：广义表是n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。" ] }, "栈":{ "key":[ "栈" ], "property":[ "type" ], "to_name":[ "线性结构" ], "重要程度":[ 3 ], "所属章节":[ "3" ], "知识点描述":[ "栈（stack）是限定在表尾进行插入和删除操作的线性表（或单链表）。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。" ] }, "顺序栈":{ "key":[ "顺序栈" ], "property":[ "type" ], "to_name":[ "栈" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "顺序栈是分配一段连续的空间，需要两个指针，base指向栈底，top指向栈顶。而链栈每个结点的地址是不连续的，只需要一个栈顶指针即可。" ] }, "链栈":{ "key":[ "链栈" ], "property":[ "type" ], "to_name":[ "栈" ], "重要程度":[ 4 ], "所属章节":[ "3" ], "知识点描述":[ "链栈的结点定义和单链表一样，只不过它只能在栈顶操作而已。链栈的基本操作：1、初始化操作InitStack；2、判断一个链栈是否为空栈StackEmpty；3、求链栈的长度StackLength；4、入栈操作Push()；5、出栈操作Pop；6、取栈顶元素操作GetTop()。" ] }, "队列":{ "key":[ "队列" ], "property":[ "type" ], "to_name":[ "线性结构" ], "重要程度":[ 2 ], "所属章节":[ "3" ], "知识点描述":[ "队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。" ] }, "循环队列":{ "key":[ "循环队列" ], "property":[ "type" ], "to_name":[ "队列" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。" ] }, "链队列":{ "key":[ "链队列" ], "property":[ "type" ], "to_name":[ "队列" ], "重要程度":[ 1 ], "所属章节":[ "3" ], "知识点描述":[ "队列中结点采取链接方式存贮的队列,称为链队列。" ] }, "线性表":{ "key":[ "线性表" ], "property":[ "type" ], "to_name":[ "线性结构" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。" ] }, "循环链表":{ "key":[ "循环链表" ], "property":[ "type" ], "to_name":[ "线性表" ], "重要程度":[ 4 ], "所属章节":[ "2" ], "知识点描述":[ "循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。" ] }, "静态链表":{ "key":[ "静态链表" ], "property":[ "type" ], "to_name":[ "线性表" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "用数组描述的链表，即称为静态链表。" ] }, "双向链表":{ "key":[ "双向链表" ], "property":[ "type" ], "to_name":[ "线性表" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。" ] }, "单链表":{ "key":[ "单链表" ], "property":[ "type" ], "to_name":[ "线性表" ], "重要程度":[ 2 ], "所属章节":[ "2" ], "知识点描述":[ "单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。" ] }, "无向图":{ "key":[ "无向图" ], "property":[ "type" ], "to_name":[ "图状结构" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "边没有方向的图称为无向图。" ] }, "有向图":{ "key":[ "有向图" ], "property":[ "type" ], "to_name":[ "图状结构" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "一个有向图D是指一个有序三元组(V(D)，A(D)，ψD)，其中ψD为关联函数，它使A(D)中的每一个元素(称为有向边或弧)对应于V(D)中的一个有序元素(称为顶点或点)对。" ] }, "完全图":{ "key":[ "完全图" ], "property":[ "type" ], "to_name":[ "无向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "在图论的数学领域，完全图是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。完整的有向图又是一个有向图，其中每对不同的顶点通过一对唯一的边缘（每个方向一个）连接。" ] }, "连通图":{ "key":[ "连通图" ], "property":[ "type" ], "to_name":[ "无向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "在一个无向图 G 中，若从顶点i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是有向图，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。" ] }, "无向完全图":{ "key":[ "无向完全图" ], "property":[ "type" ], "to_name":[ "无向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "无向完全图是用n表示图中顶点数目的一种完全图，该图中每条边都是无方向的。" ] }, "生成树":{ "key":[ "生成树" ], "property":[ "subclassof" ], "to_name":[ "无向图" ], "重要程度":[ 3 ], "所属章节":[ "6" ], "知识点描述":[ "生成树可以定义为连通的无向图G的子图，该图是通过从图中移除所需数量的边而产生的树。换句话说，生成树是连接和无向图G的非循环子图，其将所有顶点连接在一起。图G可以具有多个生成树。连通无向图的生成树包含原图中所有的点，树的边也是原图中存在的边。" ] }, "连通分量":{ "key":[ "连通分量" ], "property":[ "subclassof" ], "to_name":[ "无向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "无向图G的极大连通子图称为G的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。" ] }, "强连通分量":{ "key":[ "强连通分量" ], "property":[ "subclassof" ], "to_name":[ "无向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。" ] }, "强连通图":{ "key":[ "强连通图" ], "property":[ "type" ], "to_name":[ "有向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "强连通图(Strongly Connected Graph)是指在有向图G中，如果对于每一对vi、vj，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。" ] }, "有向完全图":{ "key":[ "有向完全图" ], "property":[ "type" ], "to_name":[ "有向图" ], "重要程度":[ 4 ], "所属章节":[ "7" ], "知识点描述":[ "有向完全图是指图中各边都有方向，且每两个顶点之间都有两条方向相反的边连接的图。" ] }, "查找算法":{ "key":[ "查找算法" ], "property":[ "subclassof" ], "to_name":[ "基本算法" ], "重要程度":[ 3 ], "所属章节":[ "9" ], "知识点描述":[ "用关键字标识一个数据元素，查找时根据给定的某个值，在表中确定一个关键字的值等于给定值的记录或数据元素。" ] }, "哈希表查找":{ "key":[ "哈希表查找" ], "property":[ "subclassof" ], "to_name":[ "动态查找法" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "哈希查找也叫散列查找，整个散列查找过程大概分两步：（1）在存储时通过散列函数计算记录的散列地址，并按此散列地址存储该记录。（2）当查找时，一样通过散列函数计算记录的散列地址，然后访问散列地址的记录。" ] }, "B-树查找":{ "key":[ "B-树查找" ], "property":[ "subclassof" ], "to_name":[ "动态查找法" ], "重要程度":[ 3 ], "所属章节":[ "9" ], "知识点描述":[ "B-树的查找类似二叉排序树的查找，所不同的是B-树每个结点上是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。B-树不支持顺序检索，仅能支持索引查找。" ] }, "B+树查找":{ "key":[ "B+树查找" ], "property":[ "subclassof" ], "to_name":[ "动态查找法" ], "重要程度":[ 3 ], "所属章节":[ "9" ], "知识点描述":[ "B+ 树是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。B+树不仅支持顺序检索，还支持索引查找。" ] }, "二叉排序树查找":{ "key":[ "二叉排序树查找" ], "property":[ "subclassof" ], "to_name":[ "动态查找法" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "在二叉排序树中进行查找的过程和二分查找类似，也是一个逐步缩小查找范围的过程。若查找成功，则是走了一条从根结点到待查结点的路径；若查找失败，则是走了一条根结点到某个叶子结点的路径。因此，查找过程中和关键字比较的次数不超过树的深度。" ] }, "折半查找":{ "key":[ "折半查找" ], "property":[ "subclassof" ], "to_name":[ "静态查找法" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "折半查找的基本思想：减少查找序列的长度，分而治之地进行关键字的查找。他的查找过程是：先确定待查找记录的所在的范围，然后逐渐缩小查找的范围，直至找到该记录为止（也可能查找失败）。" ] }, "分块查找":{ "key":[ "分块查找" ], "property":[ "同义关系" ], "to_name":[ "索引排序查找" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。" ] }, "顺序查找":{ "key":[ "顺序查找" ], "property":[ "subclassof" ], "to_name":[ "静态查找法" ], "重要程度":[ 2 ], "所属章节":[ "9" ], "知识点描述":[ "顺序查找是按照序列原有顺序对数组进行遍历比较查询的基本查找算法。" ] }, "基本算法":{ "key":[ "基本算法" ], "property":[ "subclassof" ], "to_name":[ "数据结构" ], "重要程度":[ 4 ], "所属章节":[ " " ], "知识点描述":[ ] }, "存储结构":{ "key":[ "存储结构" ], "property":[ "subclassof" ], "to_name":[ "数据结构" ], "重要程度":[ 4 ], "所属章节":[ ], "知识点描述":[ "数据元素之间的关系有两种不同的表示方法:顺序映象和非顺序映象，并由此得到两种不同的存储结构:顺序存储结构和链式存储结构。" ] }, "基本操作":{ "key":[ "基本操作" ], "property":[ "subclassof" ], "to_name":[ "数据结构" ], "重要程度":[ 3 ], "所属章节":[ ], "知识点描述":[ ] }, "排序算法":{ "key":[ "排序算法" ], "property":[ "subclassof" ], "to_name":[ "基本算法" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "所谓排序算法，即通过特定的算法因式将一组或多组数据按照既定模式进行重新排序。" ] }, "内部排序":{ "key":[ "内部排序" ], "property":[ "subclassof" ], "to_name":[ "排序算法" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。内部排序方法:1.插入排序(直接插入排序);2.快速排序;3.选择排序(简单选择排序);4.归并排序 ;5.冒泡排序;6.希尔排序;希尔排序是对直接插入排序方法的改进。7.堆排序;8.基数排序;" ] }, "外部排序":{ "key":[ "外部排序" ], "property":[ "subclassof" ], "to_name":[ "排序算法" ], "重要程度":[ 1 ], "所属章节":[ "11" ], "知识点描述":[ "外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。" ] }, "基数排序":{ "key":[ "基数排序" ], "property":[ "type" ], "to_name":[ "内部排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。" ] }, "交换排序":{ "key":[ "交换排序" ], "property":[ "type" ], "to_name":[ "内部排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是:将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。" ] }, "插入排序":{ "key":[ "插入排序" ], "property":[ "type" ], "to_name":[ "内部排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "插入排序的基本思想是:每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。" ] }, "归并排序":{ "key":[ "归并排序" ], "property":[ "type" ], "to_name":[ "内部排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。" ] }, "选择排序":{ "key":[ "选择排序" ], "property":[ "type" ], "to_name":[ "内部排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法(比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面)。" ] }, "冒泡排序":{ "key":[ "冒泡排序" ], "property":[ "subclassof" ], "to_name":[ "交换排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "每一趟只能确定将一个数归位，如果有n个数进行排序，只需将n-1个数归位，也就是说要进行n-1趟操作，而每一趟都需要从第1位开始进行相邻两个数的比较。" ] }, "快速排序":{ "key":[ "快速排序" ], "property":[ "subclassof" ], "to_name":[ "交换排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "通过一趟排序将要排序的数据分割成独立的两部分，分割点左边都是比它小的数，右边都是比它大的数。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。" ] }, "直接插入排序":{ "key":[ "直接插入排序" ], "property":[ "subclassof" ], "to_name":[ "插入排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，如此重复，直至完成序列排序。时间复杂度为 o(n^2)。" ] }, "希尔排序":{ "key":[ "希尔排序" ], "property":[ "subclassof" ], "to_name":[ "插入排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "对于n个待排序的数列，取一个小于n的整数gap(步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；对各组内的元素进行直接插入排序。这一趟排序完成之后，每一个组的元素都是有序的。减小gap的值，重复执行上述的分组和排序。当gap=1时，整个数列就是有序的。最坏时间复杂度是O(n^s) , 1<s<2, s是所选的分组。" ] }, "折半插入排序":{ "key":[ "折半插入排序" ], "property":[ "subclassof" ], "to_name":[ "插入排序" ], "重要程度":[ 4 ], "所属章节":[ "10" ], "知识点描述":[ "折半插入排序(Binary Insertion Sort)是对插入排序算法的一种改进。所谓插入排序，就是不断的依次将元素插入前面已排好序的序列中。时间复杂度为O(n^2)。" ] }, "2-路插入排序":{ "key":[ "2-路插入排序" ], "property":[ "subclassof" ], "to_name":[ "插入排序" ], "重要程度":[ 1 ], "所属章节":[ "10" ], "知识点描述":[ "2-路插入排序算法是在直接插入排序算法的基础上增加了一个辅助数组，其目的是减少排序过程中的移动次数，需要增加n个记录的辅助空间。时间复杂度为O(n^2)。" ] }, "简单选择排序":{ "key":[ "简单选择排序" ], "property":[ "subclassof" ], "to_name":[ "选择排序" ], "重要程度":[ 3 ], "所属章节":[ "10" ], "知识点描述":[ "简单选择排序的思想是，从第一位置开始，逐渐向后，选择后面的无序序列中的最小值放到该位置。" ] }, "堆排序":{ "key":[ "堆排序" ], "property":[ "subclassof" ], "to_name":[ "选择排序" ], "重要程度":[ 3 ], "所属章节":[ "10" ], "知识点描述":[ "堆排序(Heapsort)是指利用堆积树(堆)这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。" ] }, "数据库知识":{ "key":[ "数据库知识" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 1 ], "所属章节":[ 1 ], "知识点描述":[ "数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。" ] }, "关系数据库":{ "key":[ "关系数据库" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "关系数据库，是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。" ] }, "关系代数":{ "key":[ "关系代数" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "关系代数是一种抽象的查询语言,它用对关系的运算来表达查询。" ] }, "关系数据库概述":{ "key":[ "关系数据库概述" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "（1）关系数据库：在一个给定的应用领域中，所有实体及实体之间联系的集合构成一个关系数据库。（2）关系数据库的型与值：关系数据库的型称为关系数据库模式，是对关系数据库的描述，若干域的定义，在这些域上定义的若干关系模式；关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常简称为关系数据库。" ] }, "关系数据库管理系统":{ "key":[ "关系数据库管理系统" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "关系数据库管理系统（Relational Database Management System：RDBMS）是指包括相互联系的逻辑组织和存取这些数据的一套程序 (数据库管理系统软件)。关系数据库管理系统就是管理关系数据库，并将数据逻辑组织的系统。常用的关系数据库管理系统产品是Oracle、IBM的DB2和微软的SQL Server。" ] }, "关系的完整性":{ "key":[ "关系的完整性" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "关系完整性即指关系的正确性、相容性和有效性。它是给定的关系模型中数据及其联系的所有制约和依存规则，用以限定数据库状态及状态变化，从而保证数据的正确、相容和有效关系模型的完整性有三类: 实体完整性、参照完整性和用户定义的完整性。其中，实体完整性和参照完整性是关系模型必须满足的完整性约束条件。" ] }, "关系数据结构":{ "key":[ "关系数据结构" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "在关系型数据结构中，数据是用二维表格的形式来组织的，但与简单表格中的结构有本质的区别。这里的数据具有更严密的定义，如数据类型一致、数据不可再分割、两行数据不能相同等。关系数据结构具有简单、灵活、存储效率高等特性，所以在结构化数据组织过程中得到了广泛的应用。" ] }, "关系演算":{ "key":[ "关系演算" ], "property":[ "subclassof" ], "to_name":[ "关系数据库" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "关系演算是以数理逻辑中的谓词演算为基础的。以谓词演算为基础的查询语言称为关系演算语言。用谓词演算作为数据库查询语言的思想最早见于Kuhns的论文。把谓词演算用于关系数据库语(即关系演算的概念)是出E.F.Codd提出来的。" ] }, "关系数据库标准语言SQL":{ "key":[ "关系数据库标准语言SQL" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "SQL（Structured Query Language），即结构化查询语言。SQL集数据查询（Data Query）、数据操纵（Data Manipulation）、数据定义（Data Definition）和数据控制（Data Control）功能于一体。特点：综合统一；高度非过程化；面向集合的操作方式；以同一种语法结构提供两种使用方法(交互式，嵌入式)；语言简洁，易学易用。" ] }, "数据库基本表的操作":{ "key":[ "数据库基本表的操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据库基本表的操作包括定义、修改、删除基本表等操作。" ] }, "索引操作":{ "key":[ "索引操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。但是查询速度的提高是以插入，更新，删除的速度为代价的，所以索引的作用在于提高一个海量数据的检索速度。常见索引分为：主键索引(primary key)、唯一索引(unique)、普通索引(index)、全文索引(fulltext)。" ] }, "查询操作":{ "key":[ "查询操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据库的作用主要是用于对数据进行存储、更新、删除、查询操作，即“增、删、改、查”，最重要的是查询。查询操作分为单表查询、连接查询、嵌套查询、集合查询。" ] }, "数据更新":{ "key":[ "数据更新" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据更新（data revision）是以新数据项或记录、替换数据文件或数据库中与之相对应的旧数据项或记录的过程。通过删除一修改一再插入的操作来实现。" ] }, "视图操作":{ "key":[ "视图操作" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "视图在本质上是一种虚拟表，其内容与真是表相似，包含一系列带有名称的列和行数据。视图的实际功能是封装了复杂的查询语句。视图并不在数据库中以存储数据值的形式存在。行和列数据来自定义视图的查询所引用的基本表，并且在具体引用视图时动态生成。" ] }, "数据控制":{ "key":[ "数据控制" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "数据库管理系统通过以下三步来实现数据控制：授权定义、存权处理、查权操作。" ] }, "授权定义":{ "key":[ "授权定义" ], "property":[ "subclassof" ], "to_name":[ "数据控制" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "具有授权资格的用户，如数据库管理员（Database Administrators，DBA）或建表户（Database Owner，DBO），通过数据控制语言（Data Control Language，DCL），将授权决定告知数据库管理系统。" ] }, "存权处理":{ "key":[ "存权处理" ], "property":[ "subclassof" ], "to_name":[ "数据控制" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "数据库管理系统把授权的结果编译后存入数据字典中。数据字典是由系统自动生成、维护的一组表，记录着用户标识、基本表、视图和各表的列描述以及系统的授权情况。" ] }, "查权操作":{ "key":[ "查权操作" ], "property":[ "subclassof" ], "to_name":[ "数据控制" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "当用户提出操作请求时，系统首先要在数据字典中查找用户的数据操作权限，当用户拥有该操作权时才能执行其操作，否则系统将拒绝其操作。" ] }, "嵌入式SQL":{ "key":[ "嵌入式SQL" ], "property":[ "subclassof" ], "to_name":[ "关系数据库标准语言SQL" ], "重要程度":[ 3 ], "所属章节":[ 3 ], "知识点描述":[ "嵌入式SQL(英文 Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。" ] }, "关系数据库设计理论":{ "key":[ "关系数据库设计理论" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "关系数据库设计理论主要包括三个方面的内容:函数依赖、范式(Normal Form)和模式设计。其中函数依赖起着核心作用,是模式分解和模式设计的基础,范式是模式分解的标." ] }, "关系模式的规范化":{ "key":[ "关系模式的规范化" ], "property":[ "subclassof" ], "to_name":[ "关系数据库设计理论" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "关系模式的规范化实际上就是按照不同级别范式的要求条件对模式进行逐渐分解的过程。" ] }, "关系模式的分解":{ "key":[ "关系模式的分解" ], "property":[ "subclassof" ], "to_name":[ "关系模式的规范化" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "把一个关系模式分解成若干个关系模式的过程，称为关系模式的分解。关系模式分解必须遵守两个准则(1)无损联接性：信息不失真（不增减信息）。(2)函数依赖保持性：不破坏属性间存在的依赖关系。" ] }, "关系模式规范化的步骤":{ "key":[ "关系模式规范化的步骤" ], "property":[ "subclassof" ], "to_name":[ "关系模式的规范化" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "1,找出码;2,找出所有的非平凡依赖;3,找出违反范式的非平凡依赖;4,依据非平凡依赖就可以分解了。" ] }, "数据依赖":{ "key":[ "数据依赖" ], "property":[ "subclassof" ], "to_name":[ "关系数据库设计理论" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "数据依赖是指一种状态，当程序结构导致数据引用之前处理过的数据时的状态。在编译学中，数据依赖是数据分析的一部分。" ] }, "关系模式中的数据依赖":{ "key":[ "关系模式中的数据依赖" ], "property":[ "subclassof" ], "to_name":[ "数据依赖" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "数据依赖是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。现在人们已经提出了许多种类型的数据依赖，其是最重要的是函数依赖和多值依赖。" ] }, "数据依赖对关系模式的影响":{ "key":[ "数据依赖对关系模式的影响" ], "property":[ "subclassof" ], "to_name":[ "数据依赖" ], "重要程度":[ 1 ], "所属章节":[ 4 ], "知识点描述":[ "规范化理论是用来改造关系模式的，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。" ] }, "范式":{ "key":[ "范式" ], "property":[ "subclassof" ], "to_name":[ "关系数据库设计理论" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "范式就是关系数据库中满足不同规范化程度的关系模式的类。" ] }, "数据库设计":{ "key":[ "数据库设计" ], "property":[ "subclassof" ], "to_name":[ "数据库" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库设计(Database Design)是指根据用户的需求，在某一具体的数据库管理系统上，设计数据库的结构和建立数据库的过程。数据库系统需要操作系统的支持。" ] }, "数据库实施":{ "key":[ "数据库实施" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库的实施主要是根据逻辑结构设计和物理结构设计的结果,在计算机系统上建立实际的数据库结构、导入数据并进行程序的调试。" ] }, "数据库物理设计":{ "key":[ "数据库物理设计" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库物理设计就是设计数据库的物理结构，根据数据库的逻辑结构来选定RDBMS（如Oracle、Sybase等），并设计和实施数据库的存储结构、存取方式等。" ] }, "数据库运行与维护":{ "key":[ "数据库运行与维护" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库系统投入正式运行，意味着数据库的设计与开发阶段的基本结束，运行与维护阶段的开始。数据库的运行和维护是个长期的工作，是数据库设计工作的延续和提高。在数据库运行阶段，完成对数据库的日常维护，工作人员需要掌握DBMS的存储、控制和数据恢复等基本操作，而且要经常性地涉及物理数据库、甚至逻辑数据库的再设计，因此数据库的维护工作仍然需要具有丰富经验的专业技术人员(主要是数据库管理员)来完成。" ] }, "数据库设计的步骤":{ "key":[ "数据库设计的步骤" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据库设计通常分为6个阶段：（1）需求分析：分析用户的需求，包括数据、功能和性能需求；（2）概念结构设计：主要采用E-R模型进行设计，包括画E-R图；（3）逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；（4）数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；（5）数据库的实施：包括编程、测试和试运行；（6）数据库运行与维护：系统的运行与数据库的日常维护。" ] }, "概念结构设计":{ "key":[ "概念结构设计" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "概念结构设计的任务是在需求分析阶段产生的需求说明书的基础上，按照特定的方法把它们抽象为一个不依赖于任何具体机器的数据模型，即概念模型。概念模型使设计者的注意力能够从复杂的实现细节中解脱出来，而只集中在最重要的信息的组织结构和处理模式上。" ] }, "逻辑结构设计":{ "key":[ "逻辑结构设计" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "逻辑结构设计是将概念结构设计阶段完成的概念模型，转换成能被选定的数据库管理系统(DBMS)支持的数据模型。这里主要将E-R模型转换为关系模型。需要具体说明把原始数据进行分解、合并后重新组织起来的数据库全局逻辑结构，包括所确定的关键字和属性、重新确定的记录结构和文件结构、所建立的各个文件之间的相互关系，形成本数据库的数据库管理员视图。" ] }, "需求分析":{ "key":[ "需求分析" ], "property":[ "subclassof" ], "to_name":[ "数据库设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据需求分析是从对数据进行组织与存储的角度,从用户视图出发,分析与辨别应用领域所管理的各类数据项(Data Items)和数据结构,形成数据字典的主要内容。" ] }, "数据抽象":{ "key":[ "数据抽象" ], "property":[ "subclassof" ], "to_name":[ "概念结构设计" ], "重要程度":[ 2 ], "所属章节":[ 5 ], "知识点描述":[ "数据抽象结构是对现实世界的一种抽象从实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节把这些特性用各种概念精确地加以描述这些概念组成了某种模型。包括分类、聚集和概括三种常用抽象。" ] }, "概念结构设计的方法与步骤":{ "key":[ "概念结构设计的方法与步骤" ], "property":[ "subclassof" ], "to_name":[ "概念结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "概念结构设计主要有四种策略：自顶向下，自底向上，由里向外（逐步扩张）和混合策略。方法是先画出组织的局部E-R图，然后将其合并，在此基础进行优化和美化。" ] }, "视图的集成":{ "key":[ "视图的集成" ], "property":[ "subclassof" ], "to_name":[ "概念结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "把基于不同用户视角的局部ER图集成为一个统一的、没有冗余的全局ER图。局部ER图（概念数据模型）的集成一般有如下四个步骤：（1）集成策略选择（2）比较实体关系图（3）统一实体关系元素（4）合并、重构实体关系图" ] }, "E-R图向数据模型的转换":{ "key":[ "E-R图向数据模型的转换" ], "property":[ "subclassof" ], "to_name":[ "逻辑结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "一般的转换原则为：一个实体型转换为一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码。" ] }, "数据模型的优化":{ "key":[ "数据模型的优化" ], "property":[ "subclassof" ], "to_name":[ "逻辑结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "通常以规范化理论为指导，优化方法为确定数据依赖，对各个关系模式之间的数据依赖进行极小化处理。" ] }, "设计用户子模式":{ "key":[ "设计用户子模式" ], "property":[ "subclassof" ], "to_name":[ "逻辑结构设计" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "根据局部应用需求设计用户子模式。目的是保证系统安全性，简化用户对系统的使用，DBMS中一般采用视图机制。" ] }, "数据字典":{ "key":[ "数据字典" ], "property":[ "subclassof" ], "to_name":[ "需求分析" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它通常包括数据项、数据结构、数据流、数据存储和处理过程几部分。" ] }, "需求分析的任务":{ "key":[ "需求分析的任务" ], "property":[ "subclassof" ], "to_name":[ "需求分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "需求分析的任务是通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）的工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。新系统必须充分考虑今后可能的扩充和改变，不能仅仅按当前应用需求来设计数据库。" ] }, "需求分析的方法":{ "key":[ "需求分析的方法" ], "property":[ "subclassof" ], "to_name":[ "需求分析" ], "重要程度":[ 1 ], "所属章节":[ 5 ], "知识点描述":[ "从系统分析出发，可将需求分析方法大致分为功能分解方法、结构化分析方法、信息建模法和面向对象的分析方法。常用结构化分析（SA）方法：从最上层系统组织机构入手，采用自顶向下、逐层分解的方式分析系统。" ] }, "专门的关系运算":{ "key":[ "专门的关系运算" ], "property":[ "type" ], "to_name":[ "关系代数" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "专门的运算关系包括选择、投影、连接、除运算四种。" ] }, "选择":{ "key":[ "选择" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：在关系R中选出满足指定条件F的元组(行操作)。表达式：σF(R) = {t|t∈R∧F(t)='真'}" ] }, "投影":{ "key":[ "投影" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：从关系R中选出若干属性A组成新关系(列操作)。表达式：πA(R) = {t[A]|t∈R}" ] }, "连接":{ "key":[ "连接" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：从两个关系R和S的笛卡尔积中选取属性间满足指定条件AθB的元组。表达式：R∞S(AθB) = {t(r)t(s)|t(r)∈R∧t(s)∈S∧t(r)[A]θt(s)[B]}拓展关系：连接分两种：等值连接与自然连接①等值连接：指定条件AθB的θ为'='时;②自然连接：在等值连接的基础上去除重复的属性" ] }, "除运算":{ "key":[ "除运算" ], "property":[ "type" ], "to_name":[ "专门的关系运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "定义：设关系R除以关系S的结果为关系T,则T包含所有在R但不在S中的属性及值,且T的元组与S的元组的所有组合都在R中。表达式：R÷S = {t(r)[X]|t(r)∈R∧π(Y)(S)属于Y(x)},其中Y(x)为x在R中的象集,x=t(r)[X]" ] }, "传统的集合运算":{ "key":[ "传统的集合运算" ], "property":[ "type" ], "to_name":[ "关系代数" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "传统的集合运算是二目运算，它包括并、差、交、笛卡尔积4种运算。" ] }, "并":{ "key":[ "并" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域，则：关系R与关系S的并记为：R∪S={t|t∈R?t∈S}，其结果仍为n目关系，由属性R或属性S的元组组成。" ] }, "差":{ "key":[ "差" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域，则：关系R与关系S的差记为：R-S={t|t∈R?t?S}，其结果关系仍为n目关系，由属于R而不属于S的所有元组组成。" ] }, "交":{ "key":[ "交" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域，则：关系R与关系S的交记为：R∩S={t∈R?t∈S}其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交运算可以用差运算来表示，即R∩S= R-(R-S)。" ] }, "笛卡尔积":{ "key":[ "笛卡尔积" ], "property":[ "type" ], "to_name":[ "传统的集合运算" ], "重要程度":[ 4 ], "所属章节":[ 2 ], "知识点描述":[ "设关系R和S具有相同的目n(即两个关系都有n个属性)，其相应的属性取自同一个域。这里的笛卡尔积严格地讲是广义笛卡尔积(Extended Cartesian Product)。在不会出现混淆的情况下广义笛卡尔积也称为笛卡尔积。两个分别为n目和m目的关系R和S的笛卡尔积是一个n+m列的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。若R有k1个元组，S有K2个元组，则关系R和关系S的迪卡尔积有K1  K2个元组。记作：R×S={(t_r t_s ) ?|t_r∈R?t_s∈S}。" ] }, "元组关系演算语言":{ "key":[ "元组关系演算语言" ], "property":[ "type" ], "to_name":[ "关系演算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "元组关系演算以元组变量作为谓词变元的基本对象。典型的元组关系演算语言是E.F.Codd提出的ALPHA语言，但这一语言并没有实际实现。现在关系库管理系统INGRES所用的QUEL语言是参会照ALPHA语言研制的，与ALPHA十分相似。ALPHA语言语句的基本格式是:操作语句 工作空间名(表达式):操作条件" ] }, "域关系演算语言":{ "key":[ "域关系演算语言" ], "property":[ "type" ], "to_name":[ "关系演算" ], "重要程度":[ 2 ], "所属章节":[ 2 ], "知识点描述":[ "域关系演算是另一种形式的关系演算。域关系演算以元组变量的分量(即域变量)作为谓词变元的基本对象。QBE是一个很特色的域关系演算语言，穹由M.MZloof于1975年提出，关于1978年在IBM370上得以实现。QBE是Query By Example(即通过例子进行查询)的简称，它是一种关系语言，同时也指使用此语言的关系数据库时系统。" ] }, "定义基本表":{ "key":[ "定义基本表" ], "property":[ "type" ], "to_name":[ "数据库基本表的操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "SQL语言用CREATE TABLE语句定义基本表。" ] }, "修改基本表":{ "key":[ "修改基本表" ], "property":[ "type" ], "to_name":[ "数据库基本表的操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "SQL语言用ALTER TABLE语句修改基本表" ] }, "删除基本表":{ "key":[ "删除基本表" ], "property":[ "type" ], "to_name":[ "数据库基本表的操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "当某个基本表不再需要时，可以使用SQL语句DROP TABLE进行删除。" ] }, "查询索引":{ "key":[ "查询索引" ], "property":[ "type" ], "to_name":[ "索引操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "使用SHOW INDEX 命令来列出表中的相关的索引信息。实例：show index 索引名 from 表名" ] }, "创建索引":{ "key":[ "创建索引" ], "property":[ "type" ], "to_name":[ "索引操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "索引被创建于已有的表中，它可使对行的定位更快速更有效。使用CREATE 语句创建索引。实例：CREATE INDEX新建的索引名 ON 表名(表中的列)" ] }, "删除索引":{ "key":[ "删除索引" ], "property":[ "type" ], "to_name":[ "索引操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "当某个索引不再需要时，可以使用SQL语句DROP INDEX进行删除。实例：Drop index 索引名 on 表名" ] }, "单表查询":{ "key":[ "单表查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "查询仅涉及一个表，是一种最简单的查询操作。（1）选择表中的若干列（2）选择表中的若干元组（3）对查询结果排序（4）使用集函数（5）对查询结果分组" ] }, "连接查询":{ "key":[ "连接查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "内连接的连接查询结果集中仅包含满足条件的行，内连接是SQL Server缺省的连接方式，可以把INNERJOIN简写成JOIN，根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种；交叉连接的连接查询结果集中包含两个表中所有行的组合；外连接的连接查询结果集中既包含那些满足条件的行，还包含其中某个表的全部行，有3种形式的外连接：左外连接、右外连接、全外连接。" ] }, "嵌套查询":{ "key":[ "嵌套查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "嵌套查询指包含一个或多个子查询或者子查询的另一个术语的SELECT语句。其中外层查询称为主查询，内层查询称为子查询。" ] }, "集合查询":{ "key":[ "集合查询" ], "property":[ "type" ], "to_name":[ "查询操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "在数学中可以对集合做交并差运算，在 SQL 中同样可以对查询结果集做交并差操作。这三种 SQL 集合查询对应的操作符关键字分别是 INTERSECT、UNION/UNION ALL、MINUS。" ] }, "插入数据":{ "key":[ "插入数据" ], "property":[ "type" ], "to_name":[ "数据更新" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "SQL数据插入一般有两种格式，一种是单行数据插入，一种是子查询结果插入。关键词是INSERT。" ] }, "修改数据":{ "key":[ "修改数据" ], "property":[ "type" ], "to_name":[ "数据更新" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据修改的关键词是UPDATE，一般格式为：UPDATE 表名；SET 更新内容；WHERE 更新条件其中，SET子句中的更新内容是以“属性名=表达式”的形式出现的。" ] }, "删除数据":{ "key":[ "删除数据" ], "property":[ "type" ], "to_name":[ "数据更新" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "数据删除的关键词是DELETE，一般格式为：DELETE FROM表名 WHERE 删除条件；其中，DELETE子句删除表中的数据，并不影响表的结构。" ] }, "定义视图":{ "key":[ "定义视图" ], "property":[ "type" ], "to_name":[ "视图操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "语法形式：create view view_name as 查询语句;先创建t_product表，然后插入4条数据记录，最后制作视图。" ] }, "查询视图":{ "key":[ "查询视图" ], "property":[ "type" ], "to_name":[ "视图操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "语法形式：show create view view_name ;desc view_name;select * from view_name;" ] }, "更新视图":{ "key":[ "更新视图" ], "property":[ "type" ], "to_name":[ "视图操作" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "语法形式：create or replace view view_name as 查询语句;" ] }, "BC范式":{ "key":[ "BC范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。" ] }, "第一范式":{ "key":[ "第一范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "第一范式是规范化约束范式。" ] }, "第三范式":{ "key":[ "第三范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。" ] }, "第二范式":{ "key":[ "第二范式" ], "property":[ "type" ], "to_name":[ "范式" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "第二范式(Second Normal Form,2nd NF)是指每个表必须有主关键字(Primary key),其他数据元素与主关键字一一对应。若关系模式R∈1NF（即R符合第一范式），并且每一个非主属性都完全依赖于R的主码，则R∈2NF（即R符合第二范式）。" ] }, "计算机系统概述":{ "key":[ "计算机系统概述" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ ] }, "计算机系统层次结构":{ "key":[ "计算机系统层次结构" ], "property":[ "subclassof" ], "to_name":[ "计算机系统概述" ], "重要程度":[ 2 ], "所属章节":[ 1 ], "知识点描述":[ ] }, "计算机性能指标":{ "key":[ "计算机性能指标" ], "property":[ "subclassof" ], "to_name":[ "计算机系统概述" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ "计算机功能的强弱或性能的好坏，不是由某项指标决定的，而是由它的系统结构、指令系统、硬件组成、软件配置等多方面的因素综合决定的。" ] }, "软件系统":{ "key":[ "软件系统" ], "property":[ "subclassof" ], "to_name":[ "计算机系统层次结构" ], "重要程度":[ 4 ], "所属章节":[ 1 ], "知识点描述":[ "软件系统(Software Systems)是指由系统软件、支撑软件和应用软件组成的计算机软件系统，它是计算机系统中由软件组成的部分。" ] }, "硬件系统":{ "key":[ "硬件系统" ], "property":[ "subclassof" ], "to_name":[ "计算机系统层次结构" ], "重要程度":[ 4 ], "所属章节":[ 1 ], "知识点描述":[ "硬件系统是指构成计算机的物理设备，即由机械、光、电、磁器件构成的具有计算、控制、存储、输入和输出功能的实体部件。如CPU、存储器、软盘驱动器、硬盘驱动器、光盘驱动器、主机板、各种卡及整机中的主机、显示器、打印机、绘图仪、调制解调器等等，整机硬件也称“硬设备”。 " ] }, "吞吐量":{ "key":[ "吞吐量" ], "property":[ "type" ], "to_name":[ "计算机性能指标" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ "吞吐量是指对网络、设备、端口、虚电路或其他设施，单位时间内成功地传送数据的数量（以比特、字节、分组等测量）。" ] }, "响应时间":{ "key":[ "响应时间" ], "property":[ "type" ], "to_name":[ "计算机性能指标" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ "响应时间是一个计算机，显示器成像等多个领域的概念，在网络上，指从空载到负载发生一个步进值的变化时，传感器的响应时间。" ] }, "CPU时钟周期":{ "key":[ "CPU时钟周期" ], "property":[ "type" ], "to_name":[ "计算机性能指标" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ "通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要一个时钟周期。" ] }, "主频":{ "key":[ "主频" ], "property":[ "type" ], "to_name":[ "计算机性能指标" ], "重要程度":[ 3 ], "所属章节":[ 1 ], "知识点描述":[ "主频即CPU的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了CPU速度的快慢。" ] }, "数据表示":{ "key":[ "数据表示" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 3 ], "所属章节":[ 6 ], "知识点描述":[ "数据表示是指被交换数据项的语法，传输期间采用的特定形式，计算机间整数、字符和文件的转换。" ] }, "浮点数的表示":{ "key":[ "浮点数的表示" ], "property":[ "subclassof" ], "to_name":[ "数据表示" ], "重要程度":[ 2 ], "所属章节":[ 6 ], "知识点描述":[ "浮点数，顾名思义，就是小数点不固定的数。计算机中，根据小数点位置是否固定，分为两种数据格式，一种就是这个，小数点不固定，另一种是定点数，小数点是固定的。" ] }, "数制与编码":{ "key":[ "数制与编码" ], "property":[ "subclassof" ], "to_name":[ "数据表示" ], "重要程度":[ 2 ], "所属章节":[ 6 ], "知识点描述":[ "“数制”就是“数据进制”的简称，是指数据的进位计数规则，又称“进位计数制”，简称“进制”。常见：十进制，二进制等。编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。" ] }, "定点数的表示":{ "key":[ "定点数的表示" ], "property":[ "subclassof" ], "to_name":[ "数据表示" ], "重要程度":[ 2 ], "所属章节":[ 6 ], "知识点描述":[ "定点数指小数点在数中位置固定不变的数。定点数分为定点整数和定点小数，由于小数点位置固定不变，所以存储时小数点不进行存储，按照约定的位置计算数值。原理上讲，小数点的位置可以位于任何位置，但通常将定点数表示成纯小数或纯整数。" ] }, "指令系统":{ "key":[ "指令系统" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "指令系统是计算机硬件的语言系统，也叫机器语言，指机器所具有的全部指令的集合，它是软件和硬件的主要界面，反映了计算机所拥有的基本功能。" ] }, "指令寻址方式":{ "key":[ "指令寻址方式" ], "property":[ "subclassof" ], "to_name":[ "指令系统" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ "寻址方式就是处理器根据指令中给出的地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。" ] }, "CISC和RISC":{ "key":[ "CISC和RISC" ], "property":[ "subclassof" ], "to_name":[ "指令系统" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "RISC（reduced instruction set computer，精简指令集计算机）是一种执行较少类型计算机指令的微处理器.这样一来，它能够以更快的速度执行操作。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。CISC(complexinstruction set computer,复杂指令集计算机）　除了RISC，任何全指令集计算机都使用的是复杂指令集计算（CISC）。" ] }, "直接寻址":{ "key":[ "直接寻址" ], "property":[ "subclassof" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "直接寻址是一种基本的寻址方法，其特点是：在指令格式的地址的字段中直接指出操作数在内存的地址。由于操作数的地址直接给出而不需要经过某种变换，所以称这种寻址方式为直接寻址方式。" ] }, "顺序寻址":{ "key":[ "顺序寻址" ], "property":[ "subclassof" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "?由于指令地址在内存中按顺序安排，当执行一段程序时，通常是一条指令接一条指令地顺序进行。也就是说，从存储器取出第1条指令，然后执行这条指令;接着从存储器取出第2条指令，再执行第二条指令;接着再取出第3条指令。" ] }, "隐含寻址":{ "key":[ "隐含寻址" ], "property":[ "subclassof" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "这种类型的指令，不是明显地给出操作数的地址。而是在指令中隐含着操作数的地址。例如，单地址的指令格式，就不明显地在地址字段中指出第2操作数的地址，而是规定累加寄存器AC作为第2操作数地址。指令格式明显指出的仅是第1操作数的地址D。因此，累加寄存器AC对单地址指令格式来说是隐含地址。 如:DAA 。" ] }, "立即寻址":{ "key":[ "立即寻址" ], "property":[ "type" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "立即寻址方式的目的就是将操作数紧跟在操作码后面，与操作码一起放在指令代码段中，在程序运行时，程序直接调用该操作数，而不需要到其他地址单元中去取相应的操作数，上述的写在指令中的操作数也称作立即数。" ] }, "跳跃寻址":{ "key":[ "跳跃寻址" ], "property":[ "type" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "当程序转移执行的顺序时，指令的寻址就采取跳跃寻址方式。所谓跳跃，是指下条指令的地址码不是由程序计数器给出，而是由本条指令给出。注意，程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。" ] }, "寄存器寻址":{ "key":[ "寄存器寻址" ], "property":[ "type" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 4 ], "所属章节":[ 7 ], "知识点描述":[ "寄存器寻址是指操作数在寄存器中，由指令操作码中的rrr三位的值和PSW中RS1及RS0的状态，选中某个工作寄存器区的某个寄存器，然后进行相应的指令操作。" ] }, "间接寻址":{ "key":[ "间接寻址" ], "property":[ "type" ], "to_name":[ "指令寻址方式" ], "重要程度":[ 2 ], "所属章节":[ 7 ], "知识点描述":[ "间接寻址是相对直接寻址而言的，在间接寻址的情况下，指令地址字段中的形式地址不是操作数的真正地址，而是操作数地址的指示器，或者说此形式地址单元的内容才是操作数的有效地址。" ] }, "存储系统":{ "key":[ "存储系统" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "存储系统是指计算机中由存放程序和数据的各种存储设备、控制部件及管理信息调度的设备（硬件）和算法（软件）所组成的系统。" ] }, "半导体随即存储器":{ "key":[ "半导体随即存储器" ], "property":[ "type" ], "to_name":[ "存储系统" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "RAM（Random-Access Memory，随机访问内存）包括SRAM和DRAM两大类。 SRAM在存储结构上以寄存器为基本单元，访问速度快，是各类半导体存储器中读写速度最快的；同DRAM相比无需刷新，但存储密度较低，价格也十分昂贵，通常用作CPU的一级和二级缓存(L1/L2)。另外SRAM具有易失性，掉电后信息丢失" ] }, "存储器的层次结构":{ "key":[ "存储器的层次结构" ], "property":[ "subclassof" ], "to_name":[ "存储系统" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "存储器结构，指的是储存器的组成。" ] }, "多模块存储器":{ "key":[ "多模块存储器" ], "property":[ "type" ], "to_name":[ "存储系统" ], "重要程度":[ 2 ], "所属章节":[ 4 ], "知识点描述":[ "为了解决CPU与主存储器之间的速度匹配问题，在高速存储器中，普遍采用并行主存系统。即利用类似存储器扩展(位扩展、字扩展、字位扩展)的方法，将n个字长为W位的存储器并行连接，构建一个更大的存储器。并行主存有单体多字方式、多体并行方式和多体交叉方式。" ] }, "高速缓冲存储器":{ "key":[ "高速缓冲存储器" ], "property":[ "type" ], "to_name":[ "存储系统" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "高速缓冲存储器（Cache）其原始意义是指存取速度比一般随机存取记忆体（RAM）来得快的一种RAM，一般而言它不像系统主记忆体那样使用DRAM技术，而使用昂贵但较快速的SRAM技术，也有快取记忆体的名称。" ] }, "虚拟存储器":{ "key":[ "虚拟存储器" ], "property":[ "type" ], "to_name":[ "存储系统" ], "重要程度":[ 4 ], "所属章节":[ 4 ], "知识点描述":[ "在虚存管理中，虚拟地址空间是指逻辑地址空间，实地址空间是指物理地址空间；前者的大小受机器的指令地址长度的限制，而后者的大小受物理内存大小的限制。" ] }, "输入输出系统":{ "key":[ "输入输出系统" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 1 ], "知识点描述":[ "输入输出系统是计算机系统中的主机与外部进行通信的系统。它由外围设备和输入输出控制系统两部分组成，是计算机系统的重要组成部分。" ] }, "I/O接口":{ "key":[ "I/O接口" ], "property":[ "subclassof" ], "to_name":[ "输入输出系统" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "lO 接口是主机与被控对象进行信息交换的纽带。主机通过I/O 接口与外部设备进行数据交换。绝大部分I/O 接口电路都是可编程的，即它们的工作方式可由程序进行控制。" ] }, "I/O方式":{ "key":[ "I/O方式" ], "property":[ "subclassof" ], "to_name":[ "输入输出系统" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "I/O控制方式主要有程序查询方bai式、中du断方式、DMA方式和I/O通道控制方式。" ] }, "外部设备":{ "key":[ "外部设备" ], "property":[ "subclassof" ], "to_name":[ "输入输出系统" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "简称“外设”。计算机系统中输入、输出设备（包括外存储器）的统称。对数据和信息起着传输、转送和存储的作用。是计算机系统中的重要组成部分。 外围设备涉及到主机以外的任何设备。外围设备是附属的或辅助的与计算机连接起来的设备。外围设备能扩充计算机系统。" ] }, "内部接口":{ "key":[ "内部接口" ], "property":[ "type" ], "to_name":[ "I/O接口" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "对自身系统提供的接口（供系统内部调用的接口）" ] }, "外部接口":{ "key":[ "外部接口" ], "property":[ "type" ], "to_name":[ "I/O接口" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "对外部提供的接口（提供给第三方使用的接口)" ] }, "通道":{ "key":[ "通道" ], "property":[ "type" ], "to_name":[ "I/O方式" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "经常用于大型计算机的控制方式是通道方式。通道方式，即能够根据程序控制多个外部设备并提供了DMA共享的功能，而DMA只能进行固定的数据传输操作。根据数据传送方式，通道可分成字节多路通道、选择通道和数组多路通道三种类型" ] }, "程序中断":{ "key":[ "程序中断" ], "property":[ "type" ], "to_name":[ "I/O方式" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "程序中断是指计算机执行现行程序的过程中，出现某些急需处理的异常情况和特殊请求，cpu暂时终止现行程序，而转去对随机发生的更紧迫的事件进行处理，在处理完毕后，cpu将自动返回原来的程序继续执行。" ] }, "程序查询":{ "key":[ "程序查询" ], "property":[ "type" ], "to_name":[ "I/O方式" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "程序查询方式是一种程序直接控制方式,这是主机与外设间进行信息交换的最简单的方式,输入和输出完全是通过CPU执行程序来完成的。" ] }, "DMA":{ "key":[ "DMA" ], "property":[ "type" ], "to_name":[ "I/O方式" ], "重要程度":[ 4 ], "所属章节":[ 5 ], "知识点描述":[ "DMA(Direct Memory Access，直接存储器访问) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。" ] }, "输入设备":{ "key":[ "输入设备" ], "property":[ "subclassof" ], "to_name":[ "外部设备" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "输入设备：向计算机输入数据和信息的设备。是计算机与用户或其他设备通信的桥梁。输入设备是用户和计算机系统之间进行信息交换的主要装置之一。" ] }, "外存储器":{ "key":[ "外存储器" ], "property":[ "subclassof" ], "to_name":[ "外部设备" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "外储存器是指除计算机内存及CPU缓存以外的储存器，此类储存器一般断电后仍然能保存数据。常见的外存储器有硬盘、软盘、光盘、U盘等。" ] }, "输出设备":{ "key":[ "输出设备" ], "property":[ "subclassof" ], "to_name":[ "外部设备" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "输出设备（Output Device）是计算机硬件系统的终端设备，用于接收计算机数据的输出显示、打印、声音、控制外围设备操作等。也是把各种计算结果数据或信息以数字、字符、图像、声音等形式表现出来。常见的输出设备有显示器、打印机、绘图仪、影像输出系统、语音输出系统、磁记录设备等。" ] }, "鼠标":{ "key":[ "鼠标" ], "property":[ "subclassof" ], "to_name":[ "输入设备" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "鼠标，计算机的一种外接输入设备，也是计算机显示系统纵横坐标定位的指示器，因形似老鼠而得名（港台作滑鼠）。" ] }, "键盘":{ "key":[ "键盘" ], "property":[ "subclassof" ], "to_name":[ "输入设备" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "键盘是用于操作设备运行的一种指令和数据输入装置，也指经过系统安排操作一台机器或设备的一组功能键（如打字机、电脑键盘）。" ] }, "磁盘存储器":{ "key":[ "磁盘存储器" ], "property":[ "subclassof" ], "to_name":[ "外存储器" ], "重要程度":[ 3 ], "所属章节":[ 4 ], "知识点描述":[ "磁盘存储器（magnetic disk storage），以磁盘为存储介质的存储器。它是利用磁记录技术在涂有磁记录介质的旋转圆盘上进行数据存储的辅助存储器。具有存储容量大、数据传输率高、存储数据可长期保存等特点。" ] }, "打印机":{ "key":[ "打印机" ], "property":[ "subclassof" ], "to_name":[ "输出设备" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "打印机（Printer) 是计算机的输出设备之一，用于将计算机处理结果打印在相关介质上。" ] }, "显示器":{ "key":[ "显示器" ], "property":[ "subclassof" ], "to_name":[ "输出设备" ], "重要程度":[ 3 ], "所属章节":[ 5 ], "知识点描述":[ "显示器（display）通常也被称为监视器。显示器是属于电脑的I/O设备，即输入输出设备。它是一种将一定的电子文件通过特定的传输设备显示到屏幕上再反射到人眼的显示工具。" ] }, "总线":{ "key":[ "总线" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 3 ], "知识点描述":[ "总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。" ] }, "总线操作和定时":{ "key":[ "总线操作和定时" ], "property":[ "subclassof" ], "to_name":[ "总线" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "总线定时：总线在双方交换数据的过程中需要时间上配合关系的控制。这种关系称为总线定时。实质是一种协议或规则。有同步与异步两种。" ] }, "总线仲裁":{ "key":[ "总线仲裁" ], "property":[ "subclassof" ], "to_name":[ "总线" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "系统中多个设备或模块可能同时申请对总线的使用权，为避免产生总线冲突，需由总线仲裁机构合理地控制和管理系统中需要占用总线的申请者，在多个申请者同时提出总线请求时，以一定的优先算法仲裁哪个应获得对总线的使用权。" ] }, "总线标准":{ "key":[ "总线标准" ], "property":[ "subclassof" ], "to_name":[ "总线" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "总线标准是系统与各模块、模块与模块之间的一个互连的标准界面。 " ] }, "分布仲裁方式":{ "key":[ "分布仲裁方式" ], "property":[ "subclassof" ], "to_name":[ "总线仲裁" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器从仲裁总线上得到的仲裁号与自己的仲裁号比较。若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上" ] }, "集中仲裁方式":{ "key":[ "集中仲裁方式" ], "property":[ "subclassof" ], "to_name":[ "总线仲裁" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，基本由 CPU 进行处理。集中仲裁又可分为链式查询方式、计数器定时查询方式和独立请求方式三种" ] }, "独立请求":{ "key":[ "独立请求" ], "property":[ "type" ], "to_name":[ "集中仲裁方式" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "每个设备都有一对总线请求线和总线允许线，当部件需要使用总线时，经各自的总线请求线向总线控制器发送总线请求信号，在控制器中排队，总线控制器按一定的优先次序决定批准某个部件的请求，并经该部件的总线允许线向该部件发送总线响应信号，将总线控制器交给该部件。" ] }, "计数器定时查询":{ "key":[ "计数器定时查询" ], "property":[ "type" ], "to_name":[ "集中仲裁方式" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "采用一个计数器来控制总线使用权，因此增加了一组设备地址线，少了总线响应线，仍是共有一根总线请求线。工作原理如下，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件，当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。" ] }, "链式查询":{ "key":[ "链式查询" ], "property":[ "type" ], "to_name":[ "集中仲裁方式" ], "重要程度":[ 2 ], "所属章节":[ 3 ], "知识点描述":[ "总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器，总线控制器便查询总线是否忙碌，如不忙碌便立即发总线响应信号到 BG 线串行地从一个部件传送到下一个部件，依次查询，直到某个部件有总线请求便不再传下去。" ] }, "中央处理器":{ "key":[ "中央处理器" ], "property":[ "subclassof" ], "to_name":[ "name" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。" ] }, "CPU功能":{ "key":[ "CPU功能" ], "property":[ "subclassof" ], "to_name":[ "中央处理器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "功能主要是解释计算机指令以及处理计算机软件中的数据" ] }, "指令执行过程":{ "key":[ "指令执行过程" ], "property":[ "subclassof" ], "to_name":[ "中央处理器" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ ] }, "基本构成":{ "key":[ "基本构成" ], "property":[ "subclassof" ], "to_name":[ "中央处理器" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ ] }, "操作控制":{ "key":[ "操作控制" ], "property":[ "type" ], "to_name":[ "CPU功能" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ ] }, "中断处理":{ "key":[ "中断处理" ], "property":[ "type" ], "to_name":[ "CPU功能" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "当CPU（中央处理器）执行一条现行指令的时候，如果外设向CPU发出中断请求，那么CPU在满足响应的情况下，将发出中断响应信号，与此同时关闭中断，表示CPU不在受理另外一个设备的中断。这时，CPU将寻找中断请求源是哪一个设备，并保存CPU自己的程序计数器（PC）的内容。然后，他将转移到处理该中断源的中断服务程序。CPU在保存现场信息，设备服务（如交换数据）以后，将恢复现场信息。在这些动作完成以后，开放中断，并返回到原来被中断的主程序的下一条指令。" ] }, "指令控制":{ "key":[ "指令控制" ], "property":[ "type" ], "to_name":[ "CPU功能" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ ] }, "数据加工":{ "key":[ "数据加工" ], "property":[ "type" ], "to_name":[ "CPU功能" ], "重要程度":[ 2 ], "所属章节":[ 8 ], "知识点描述":[ ] }, "时间控制":{ "key":[ "时间控制" ], "property":[ "type" ], "to_name":[ "CPU功能" ], "重要程度":[ 2 ], "所属章节":[ 8 ], "知识点描述":[ ] }, "取指":{ "key":[ "取指" ], "property":[ "subclassof" ], "to_name":[ "指令执行过程" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "取指令（Instruction Fetch，IF）阶段是将一条指令从主存中取到指令寄存器的过程。" ] }, "分析":{ "key":[ "分析" ], "property":[ "subclassof" ], "to_name":[ "指令执行过程" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "将指令寄存器中的指令操作码取出后进行译码，分析其指令性质。如指令要求操作数，则寻找操作数地址。" ] }, "执行":{ "key":[ "执行" ], "property":[ "subclassof" ], "to_name":[ "指令执行过程" ], "重要程度":[ 2 ], "所属章节":[ 9 ], "知识点描述":[ "此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。" ] }, "控制器":{ "key":[ "控制器" ], "property":[ "subclassof" ], "to_name":[ "基本构成" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "控制器（英文名称：controller）是指按照预定顺序改变主电路或控制电路的接线和改变电路中电阻值来控制电动机的启动、调速、制动和反向的主令装置。由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成，它是发布命令的“决策机构”，即完成协调和指挥整个计算机系统的操作。" ] }, "运算器":{ "key":[ "运算器" ], "property":[ "subclassof" ], "to_name":[ "基本构成" ], "重要程度":[ 4 ], "所属章节":[ 8 ], "知识点描述":[ "计算机中执行各种算术和逻辑运算操作的部件。运算器的基本操作包括加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件（ALU）。" ] } }